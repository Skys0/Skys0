<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>补题计划---摆花（有意思的一道dp）</title>
    <link href="/2024/11/09/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E6%91%86%E8%8A%B1%EF%BC%88%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%B8%80%E9%81%93dp%EF%BC%89/"/>
    <url>/2024/11/09/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E6%91%86%E8%8A%B1%EF%BC%88%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%B8%80%E9%81%93dp%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>补题计划，也是我的oi生涯的最后一章，如果这一次能够成功，至少就能达到我的计划---至少登上最后的比赛一次，为了自己那几年高中的努力，泪水，确实，该开始了，如果12月的那次校级比赛，没有得到大三的认可，那......这次的oi之旅真的要结束了。我虽然也不想让他翻篇，不想结束那些在机房里一个静静地写题，不被任何人认可的那段寂静。但天下没有不散的宴席，如果没有，那么该翻篇了。最后一次。</p><blockquote><p>时间、运气、命运对 OIer 们来说是残酷的字眼。再强的OIer，也有退役的时刻。再努力的 OIer，也难以保证他在省选或 NOI一定能够有和他的付出对等的回报。这是很多 OIer心知肚明的事实，也是我们无力感的根源。</p><p>也正因为此，有的人选择了把OI当成生命中的过客，没有对它付出过多的精力和情感。但另外一些人仍然把OI当作自己的归宿，甚至当成生活的全部。究其原因，是因为他们给OI这个词赋予了太多的意义和价值。</p><p>他们坚持停课，坚持与班主任老师、甚至家长“对抗”，坚持自己心中的目标。他们舍弃了睡觉时间来打CF，舍弃了文化课来刷模拟赛。有时，他们要面对的是孤独、不理解和对自己前途的恐惧。你可以说，这是坚持、执着、勇往直前，但在命运面前，这是渺小、卑微的。一场考试的结果是难以预料的，一个字符之差就可能是100 分与 0 分之差，一个部分分之差就可能是 20多名的差距。最勤奋的人，也不敢说，自己能够掌握自己的未来。</p></blockquote><h2 id="摆花">摆花</h2><h3 id="题目描述">题目描述</h3><p>小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 <spanclass="math inline">\(m\)</span>盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 <spanclass="math inline">\(n\)</span> 种花，从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 标号。为了在门口展出更多种花，规定第<span class="math inline">\(i\)</span> 种花不能超过 <spanclass="math inline">\(a_i\)</span>盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。</p><p>试编程计算，一共有多少种不同的摆花方案。</p><h3 id="输入格式">输入格式</h3><p>第一行包含两个正整数 <span class="math inline">\(n\)</span> 和 <spanclass="math inline">\(m\)</span>，中间用一个空格隔开。</p><p>第二行有 <span class="math inline">\(n\)</span>个整数，每两个整数之间用一个空格隔开，依次表示 <spanclass="math inline">\(a_1,a_2, \cdots ,a_n\)</span>。</p><h3 id="输出格式">输出格式</h3><p>一个整数，表示有多少种方案。注意：因为方案数可能很多，请输出方案数对<span class="math inline">\(10^6+7\)</span> 取模的结果。</p><h3 id="样例-1">样例 #1</h3><h4 id="样例输入-1">样例输入 #1</h4><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><h4 id="样例输出-1">样例输出 #1</h4><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">2<br></code></pre></div></td></tr></table></figure><h4 id="提示">提示</h4><p>【数据范围】</p><p>对于 <span class="math inline">\(20\%\)</span> 数据，有 <spanclass="math inline">\(0&lt;n \le 8,0&lt;m \le 8,0 \le a_i \le8\)</span>。</p><p>对于 <span class="math inline">\(50\%\)</span> 数据，有 <spanclass="math inline">\(0&lt;n \le 20,0&lt;m \le 20,0 \le a_i \le20\)</span>。</p><p>对于 <span class="math inline">\(100\%\)</span> 数据，有 <spanclass="math inline">\(0&lt;n \le 100,0&lt;m \le 100,0 \le a_i \le100\)</span>。</p><h2 id="思路">思路</h2><p>刚开始我想的是让 <span class="math inline">\(dp_{i,j,k}\)</span>表示为摆在第i个位置，摆的第j种花盆的第k个。但是好像细想有点反直觉，就是有点感觉有点不对。最后我想到，其实i可以省略，因为这个摆的花盆与j与k有关（因为题目说花盆有序），就是一个单调不下降子序列。</p><p>本来想是通过直接去掉i，但是细想这种又有点不对，最后求最后有多少种的时候又有不知道输出什么。</p><p>看了我之前的代码，我理解了，就是可以定义 <spanclass="math inline">\(d_{i,j}\)</span> 为在用到第 i 种花时，用了第 <spanclass="math inline">\(j\)</span> 盆花的方案数（<strong>注意：这里<spanclass="math inline">\(j\)</span>指的是全体的<spanclass="math inline">\(j\)</span>盆，而不是<spanclass="math inline">\(a_{i}\)</span>的第<spanclass="math inline">\(j\)</span>盆</strong>。</p><p>这样对于每个 <span class="math inline">\(d_{i,j}\)</span>可以去更新后面的 <span class="math inline">\(d_{i+1,j+k}\)</span>，k表示对于第 i 种花的约束。</p><p>那么动态转移方程为：</p><p><span class="math display">\[d_{i+1,j+k} = d_{i+1,j+k} + d_{i,j}\qquad (k = 1,2,....a_i)\]</span></p><p>那么就挺简单的了，三重循环搞定。时间复杂度为 <spanclass="math inline">\(O(n^3)\)</span>，对这道题完全足够。</p><p>以后遇到好题，或者让我看题解的题目都会加入补题计划（如果这次失败了，那也该和OI说再见了，一心一意的开始考研了）。</p>]]></content>
    
    
    <categories>
      
      <category>算法、 - 补题计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVL树</title>
    <link href="/2024/10/05/AVL%E6%A0%91/"/>
    <url>/2024/10/05/AVL%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="avl-树">AVL 树</h1><h2 id="前言">前言</h2><p>AVL树是二叉搜索&amp;平衡树的一种，能够担任快速地插入，查找，等操作的数据结构。二叉搜索树上的基本操作所花费的时间与这棵树的高度成正比。对于一个有<span class="math inline">\(n\)</span>个结点的二叉搜索树中，这些操作的最优时间复杂度为 <spanclass="math inline">\(O(\log n)\)</span>，最坏为 <spanclass="math inline">\(O(n)\)</span>。</p><h2 id="二叉搜索树的定义">二叉搜索树的定义</h2><ul><li>空树为二叉搜索树</li><li>如果二叉搜索树的左子树不为空，那么它的左子树上所有点的附加权值均小于其根节点的值。</li><li>若二叉搜索树的右子树不为空，则其右子树上所有点的附加权值均大于其根节点的值。</li><li>二叉搜索树的左右子树均为二叉搜索树。</li></ul><p>简单来说，就是一棵树满足全部左子树的值小于其根节点，全部右子树的值大于其根节点。</p><h2 id="节点的定义">节点的定义</h2><p>与正常的树相同，有左右子节点。还有需要维护的总体大小，高度。全部用指针实现。在保存时只需保存根节点的指针就行。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLTreeNote</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> key;<br>AVLTreeNote *Left;<br>AVLTreeNote *Right;<br><span class="hljs-keyword">int</span> height;<br><span class="hljs-keyword">int</span> size;<br><span class="hljs-keyword">int</span> count;<br><span class="hljs-built_in">AVLTreeNote</span>(<span class="hljs-keyword">int</span> value): <span class="hljs-built_in">key</span>(value), <span class="hljs-built_in">size</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">Left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">Right</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">height</span>(<span class="hljs-number">1</span>) &#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="基本操作">基本操作</h2><h3 id="遍历">遍历</h3><p>对于一个符合要求的二叉平衡树，它的中序遍历为非降的序列。那么可以利用这个性质来debug。(在小范围数据特别好用)，时间复杂度为<span class="math inline">\(O(n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 树的中序遍历，并且按顺序输出节点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Traversal</span><span class="hljs-params">(AVLTreeNote* root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">Traversal</span>(root-&gt;Left);<br>cout&lt;&lt;<span class="hljs-string">&quot;root-&gt;key: &quot;</span>&lt;&lt;root-&gt;key&lt;&lt;<span class="hljs-string">&quot; height: &quot;</span>&lt;&lt;root-&gt;height&lt;&lt;<span class="hljs-string">&quot; size: &quot;</span>&lt;&lt;root-&gt;size&lt;&lt;<span class="hljs-string">&quot; count : &quot;</span>&lt;&lt;root-&gt;count&lt;&lt;<span class="hljs-string">&quot; Left(if have): &quot;</span>&lt;&lt;(root-&gt;Left ? root-&gt;Left-&gt;key : <span class="hljs-number">-1</span>)&lt;&lt;<span class="hljs-string">&quot; Right(if have): &quot;</span>&lt;&lt;(root-&gt;Right ? root-&gt;Right-&gt;key : <span class="hljs-number">-1</span>)&lt;&lt;endl;<br><span class="hljs-built_in">Traversal</span>(root-&gt;Right);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="寻找最大最小值">寻找最大最小值</h3><p>一个二叉搜索树上的最小值为二叉搜索树左链的顶点，最大值为二叉搜索树右链的顶点。时间复杂度为<span class="math inline">\(O(h)\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉平衡树</tag>
      
      <tag>AVL 树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序（Heapsort）</title>
    <link href="/2024/09/04/%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heapsort%EF%BC%89/"/>
    <url>/2024/09/04/%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heapsort%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="堆排序heapsort">堆排序（Heapsort）</h1><p>堆排序指利用堆数据结构所设计的一种排序算法，</p><h2 id="排序">排序</h2><p>首先建立大顶堆，然后将堆顶的元素取出，作为最大值，与数组尾部的元素交换，并维持残余堆的性质；</p><p>之后将堆顶的元素取出，作为次大值，与数组倒数第二位元素交换，并维持残余堆的性质；</p><p>以此类推，在第 <span class="math inline">\(n-1\)</span>次操作后，整个数组就完成了排序。</p><ul><li>如何从一个无序序列建成一个堆？</li><li>如何将堆顶的元素取出之后，调整剩余元素成为一个新的堆？</li></ul><p>下面是具体步骤：</p><p>先解决第一个问题，首先现将数组从上至下转换成二叉树，对于一个节点<span class="math inline">\(i\)</span>，它的父节点为 <spanclass="math inline">\(i/2\)</span>，左儿子为 <spanclass="math inline">\(2 \times i\)</span>，右儿子为 <spanclass="math inline">\(2 \times i + 1\)</span>。现在是无序堆，我们要让这个无序堆变成最大堆（最小堆）。</p><p>从最后一个子堆开始，首先开始对比左右儿子，有的话取较大的子节点，再与父节点相比，如果比父节点大，那么就将儿子与父亲交换，这样一个子堆就变成了最大堆。</p><p>最后自顶向上去创建最大堆，直至最大堆完成。</p><p>将创建完成的最大堆的父节点给下放，放到最下面的一个节点，不动它了，之后对前面的继续变成最大堆，不断重复这些步骤。</p><h3 id="例子">例子</h3><p>首先我们选一个数组 [100, 5, 3, 11, 33, 6, 8,7]，按照数组顺序来构建一棵树。如下图</p><figure><img src="https://s2.loli.net/2024/09/08/tTX1eJirlWSyq8L.png"alt="graph" /><figcaption aria-hidden="true">graph</figcaption></figure><p>按照步骤，先看最后一个子堆，就是最下面的 11，发现 11没有右儿子，有个左儿子 7，符合最大堆的性质，现在在看以 5为父节点的堆，发现右儿子更大，再与父节点比较，发现儿子比父节点大，那么 5和 33 交换，交换后子堆符合最大堆的性质。</p><figure><img src="https://s2.loli.net/2024/09/08/8HYlK2rPO7SD5VF.png"alt="graph_1" /><figcaption aria-hidden="true">graph_1</figcaption></figure><p>再按照上面的规则将 3 的堆，变成最大堆，再将 100为父节点的堆变成最大堆，最后成为下图：</p><figure><img src="https://s2.loli.net/2024/09/08/ZXOEij3dUBwmLK1.png"alt="graph_2" /><figcaption aria-hidden="true">graph_2</figcaption></figure><p>这样我们第一步就完成了，下面将整个最大堆的父节点 100放到堆的末尾(实际上是100与7交换)，我们就不管它了。</p><figure><img src="https://s2.loli.net/2024/09/08/li8VRZKedbEJzak.png"alt="graph_3" /><figcaption aria-hidden="true">graph_3</figcaption></figure><p>然后继续开始最大堆调整，直至一轮结束，在 7升至顶部之后，对顶部重新做最大堆调整，左孩子33代替7的位置。这里就不给图了。</p><p>最后不断建立最大堆，并且扩大有序区，最终全部有序，最终图如下图所示</p><figure><img src="https://s2.loli.net/2024/09/10/23CHIv95YDNyGWV.png"alt="graph6.png" /><figcaption aria-hidden="true">graph6.png</figcaption></figure><h2 id="代码">代码</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x,<span class="hljs-keyword">int</span> *y)</span></span>&#123;       <span class="hljs-comment">// 交换代码</span><br><span class="hljs-keyword">int</span> tmp = *x;<br>*x = *y;<br>*y = tmp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">max_heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> end)</span></span>&#123;            <span class="hljs-comment">// 对于 start到end的堆，从顶上开始往下去让整个堆符合最大堆的性质</span><br><span class="hljs-keyword">int</span> dad = start;<br><span class="hljs-keyword">int</span> son =  dad * <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span>(son &lt;= end)&#123;      <span class="hljs-comment">// 如何儿子没有超过范围，也就是这个父节点有儿子的话</span><br><span class="hljs-keyword">if</span>(son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; a[son] &lt; a[son+<span class="hljs-number">1</span>])     <span class="hljs-comment">//两个儿子比较</span><br>son ++;<br><span class="hljs-keyword">if</span>(a[dad] &gt; a[son]) <span class="hljs-comment">// 儿子与父节点比较</span><br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span>&#123;       <span class="hljs-comment">// 如果不符合最大堆的性质，则交换父节点与子节点</span><br>swap(&amp;a[dad],&amp;a[son]);<br>dad = son;<br>son = dad * <span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">()</span>     <span class="hljs-comment">// 真正的堆排序</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)<br>max_heapify(i,n);       <span class="hljs-comment">// 第一次完整的堆排序</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;<span class="hljs-number">1</span>;i--)&#123;<br>swap(&amp;a[<span class="hljs-number">1</span>],&amp;a[i]);      <span class="hljs-comment">// 将父节点下放</span><br>max_heapify(<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>);     <span class="hljs-comment">// 注意是 i-1</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>堆排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>稳定匹配(stable Matching)问题</title>
    <link href="/2024/08/28/%E7%A8%B3%E5%AE%9A%E5%8C%B9%E9%85%8D-stable-Matching/"/>
    <url>/2024/08/28/%E7%A8%B3%E5%AE%9A%E5%8C%B9%E9%85%8D-stable-Matching/</url>
    
    <content type="html"><![CDATA[<p>在学 UCBCS70时，有一个note专门讲了这问题————稳定匹配问题，用了两天时间稍微理解了一些些。</p><h1 id="稳定匹配问题">稳定匹配问题</h1><h2id="提议与拒绝算法the-propose-and-reject-algorithm">提议与拒绝算法(ThePropose-and-Reject Algorithm)</h2><p>Note 上就是这么命名的，也称盖尔-沙普利算法(Gale–Shapleyalgorithm)。</p><ol type="1"><li>每个职位（男士）向自己优先列表中尚未拒绝的最优先候选人提出邀请。</li><li>每位候选人（女士）收集所有在这一次收到的邀请，对于她最喜欢的邀请，他回应“可以”，对于其他排名的邀请，她直接拒绝这些提议。</li><li>每个被拒绝的职位将拒绝的候选人从其列表中划掉</li></ol><p>上述循环每天重复，直到没有邀请被拒绝。</p><h2 id="提议与拒绝算法的性质">提议与拒绝算法的性质</h2><ul><li>这个算法总是会停止。</li></ul><p>证明：论证很简单：在算法未停止的每一天，至少有一个职位必须从其列表中删除一些候选人（否则算法的停止条件将会被触发）。由于每个列表有<span class="math inline">\(n\)</span> 个元素，而总共有 <spanclass="math inline">\(n\)</span> 个列表，这意味着算法最多在 <spanclass="math inline">\(n^2\)</span> 次迭代（天）后终止。</p><h3 id="稳定性">稳定性</h3><p>一个好的匹配应该具有什么性质？或许我们希望最大化首选的数量？或者，我们可以最小化最后选择的数量。或者理想情况下，我们可以最小化选择排名的总和，这可以被视为最大化平均幸福感。</p><p>在本讲中，我们将专注于一个更基本的标准，这个标准根植于自主性的理念，即<strong>稳定性</strong>。如果存在一个职位（男士）和一个候选人（女士），他们都希望与对方合作，而不是与他们当前的匹配对象合作，那么这个匹配就是<strong>不稳定的</strong>。我们将这样的配对称为<strong>不和谐对</strong>。因此，n个职位与 n 个候选人的匹配是稳定的，如果它没有不和谐对。</p><p>在讨论如何找到一个稳定的匹配之前，让我们先问一个更基本的问题：<strong>稳定的匹配总是存在吗？</strong>答案显然是肯定的。对于任何不稳定的匹配，从上面的不稳定的定义来看，总可以找到一个其他的人，来拆散当前的匹配对象。</p><h3 id="分析稳定性">分析稳定性</h3><ul><li><strong>引理1：</strong> 如果职位 <spanclass="math inline">\(J\)</span> 在第 <spanclass="math inline">\(k\)</span> 天向候选人 <spanclass="math inline">\(C\)</span> 提出提议，那么在随后的每一天 <spanclass="math inline">\(C\)</span> 都会收到一个她至少和 <spanclass="math inline">\(J\)</span>一样喜欢的职位提议（即“在手中的”职位）。</li></ul><p>证明不证了，看了大概，只能看懂，开了一个坑，等后面这个课结束了在来填。</p><ul><li><p><strong>引理2：</strong>提议与拒绝算法总是终止于一个匹配。</p></li><li><p><strong>定理1：</strong> 该算法生成的匹配总是稳定的。</p></li></ul><p>证明：这次我们从职位的角度来证明稳定性，我们直接证明在算法生成的匹配中，没有职位会涉及不和谐对。考虑最终匹配中的任何一对<span class="math inline">\((J, C)\)</span>，假设 <spanclass="math inline">\(J\)</span> 更喜欢某个候选人 <spanclass="math inline">\(C_{*}\)</span> 而不是<spanclass="math inline">\(C\)</span>。我们将论证 <spanclass="math inline">\(C_{*}\)</span> 更喜欢她的职位而不是 <spanclass="math inline">\(J\)</span>，因此 <span class="math inline">\((J,C_*)\)</span>不能构成不和谐对。由于 <spanclass="math inline">\(C_*\)</span> 在 <spanclass="math inline">\(J\)</span> 的列表中比 <spanclass="math inline">\(C\)</span> 靠前，<spanclass="math inline">\(J\)</span> 必然在向C提出提议之前先向 <spanclass="math inline">\(C_*\)</span> 提出了提议。因此，根据改善引理，<spanclass="math inline">\(C_*\)</span> 至少和 <spanclass="math inline">\(J\)</span>一样喜欢她最终获得的职位，因此更喜欢她的职位而不是 <spanclass="math inline">\(J\)</span>。因此，没有职位会涉及不和谐对，匹配是稳定的。</p><h3 id="最优性">最优性</h3><p>上面我们证明了这个算法总会存在稳定的匹配。但是在现实生活中不会仅仅追求这个，还要追求最好，那么最优性应运而生。</p><ul><li><strong>定义1 （职位的最佳候选人）</strong>对于给定职位J，J的最佳候选人是所有稳定匹配中J可以配对的最高排名<em>候选人</em>（注意候选人是双方都看得上的）。</li><li><strong>定义4.3 （候选人的最佳职位）</strong>对于给定候选人C，C的最佳职位是所有稳定匹配中C可以配对的最高排名的职位。</li></ul><p><strong>定理2：</strong>提议与拒绝算法输出的匹配总是对于一方最优的。</p><p>假设不是对于一方最优的，我们先举个栗子，可能不是对雇主最优的。那么，在某一天(第k 天)，J 被他的最佳候选人 C 拒绝，C 选择了 K的位置，那么根据最佳候选人的定义，必然存在一个稳定匹配，其中 J 与 T配对，那么这个稳定匹配为 <span class="math inline">\(\{\dotsc \{J,T\},\{C,K\} \dotsc\}\)</span>。</p><p>下面来证明(T,K) 是不和谐对。按照上面的逻辑，T更喜欢K而不是J。由于第 k天是某个职位第一次被其最佳候选人拒绝的日子，在第k天之前，职位 T没有被其最佳候选人拒绝过。由于 T 在第 k 天向 K 提出了提议，这表明 T至少和它的最佳候选人一样喜欢C*，因此至少和它在稳定匹配T中的配对 K一样喜欢T。因此，(T,K)在匹配中形成了一个不和谐对，所以匹配中不是稳定的。</p><h2 id="相关代码">相关代码</h2><p>就是很经典的题目，男士与女士结婚配对。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Stable_Marriage</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始话女士与男士的对象</span><br><span class="hljs-built_in">memset</span>(man,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(man));<br><span class="hljs-built_in">memset</span>(woman,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(woman));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)rank[i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 开始匹配</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">int</span> sign = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(!man[i])&#123;    <span class="hljs-comment">// 如果男士不是单身狗</span><br><span class="hljs-keyword">int</span> g = men[i][rank[i] ++];     <span class="hljs-comment">// 向没有被拒绝的女士发出邀请</span><br><span class="hljs-keyword">if</span>(!woman[g])&#123; <br>                    <span class="hljs-comment">// 如果女士也没有对象</span><br>woman[g] = i;man[i] = g;<br>&#125;<br>                <span class="hljs-comment">// 如果有了，判断现在的男士提出的申请是否比原来的对象，如果好。就换一个</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sc_woman[g][i] &lt; sc_woman[g][woman[g]])&#123;<br>man[woman[g]] = <span class="hljs-number">0</span>;  <br>                    <span class="hljs-comment">// 把原来的甩了</span><br>woman[g] = i;man[i] = g;<br>&#125;<br>sign = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>        <span class="hljs-comment">// 如果所有的男士都有对象，那么这个匹配已经OK了</span><br><span class="hljs-keyword">if</span>(!sign)<span class="hljs-keyword">break</span>;<br>&#125;<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,woman[man[i]],man[i]);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Stable Matching</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UCB CS70: discrete Math and probability theory</title>
    <link href="/2024/08/17/UCB-CS70-discrete-Math-and-probability-theory/"/>
    <url>/2024/08/17/UCB-CS70-discrete-Math-and-probability-theory/</url>
    
    <content type="html"><![CDATA[<h2 id="集合的复习以及数学标记">集合的复习以及数学标记</h2><h3 id="集合">集合</h3><p>集合可以包含任何东西，包括集合，任何元素。如过元素 <spanclass="math inline">\(x\)</span> 在集合 <spanclass="math inline">\(A\)</span> 中，那么记作 <spanclass="math inline">\(x \in A\)</span>。如果 <spanclass="math inline">\(y\)</span> 不属于 <spanclass="math inline">\(A\)</span> 中，那么记作 <spanclass="math inline">\(y \notin A\)</span>。</p><p>集合的基本属性：</p><ul><li>集合中不存在顺序</li><li>如果<span class="math inline">\(A,B\)</span>两个集合相等，那么记作<span class="math inline">\(A = B\)</span><br /></li></ul><h3 id="基数cardinality">基数(Cardinality)</h3><p>集合中的元素的个数，记作基数，比如 <span class="math inline">\(A =\{1,2,2,4\}\)</span>，基数为 4，记作 <span class="math inline">\(\midA\mid=4\)</span>.</p><p>如果基数为0，那么被称为空集，记作 <spanclass="math inline">\(\emptyset\)</span>。</p><h3 id="集合的基本运算">集合的基本运算</h3><h4 id="并运算">并运算</h4><p>设 <span class="math inline">\(A,B\)</span> 为两个集合，则由集合<span class="math inline">\(A\)</span> 和集合 <spanclass="math inline">\(B\)</span> 中的所有元素汇集而成的集合称为集合<span class="math inline">\(A\)</span> 和集合 <spanclass="math inline">\(B\)</span> 的 并。记作 <spanclass="math inline">\(A \cup B\)</span>。即：</p><p><span class="math inline">\(A \cup B = \{x \mid x\in A \vee x \inB\}\)</span></p><p>基本推理：</p><ul><li><span class="math inline">\(A \cup B = B \cup A\)</span></li><li><span class="math inline">\(A \cup \emptyset = A\)</span></li></ul><h4 id="交运算">交运算</h4><p>设 <span class="math inline">\(A,B\)</span> 为两个集合，则由集合<span class="math inline">\(A\)</span> 和集合 <spanclass="math inline">\(B\)</span> 中的公共元素汇集而成的集合称为集合<span class="math inline">\(A\)</span> 和集合 <spanclass="math inline">\(B\)</span> 的 并。记作 <spanclass="math inline">\(A \cap B\)</span>。即：</p><p><span class="math inline">\(A \cap B=\{x \mid x\in A \wedge x \inB\}\)</span></p><p>基本推论： * <span class="math inline">\(A \cap B = B \cap A\)</span>* <span class="math inline">\(A \cap \emptyset = \emptyset\)</span></p><h4 id="差运算">差运算</h4><p>设 <span class="math inline">\(A,B\)</span> 为两个集合，则由属于集合<span class="math inline">\(A\)</span> 但不属于集合 <spanclass="math inline">\(B\)</span> 的所有元素汇集的集合称为集合 <spanclass="math inline">\(A\)</span> 与集合 <spanclass="math inline">\(B\)</span> 的差。记作 <spanclass="math inline">\(A\backslash B\)</span> 或 <spanclass="math inline">\(A − B\)</span>。即：</p><p><span class="math inline">\(A\backslash B= \{x \in A \mid x \notinB\}\)</span></p><p>基本推论： * <span class="math inline">\(A \backslash B =\emptyset\)</span> * <span class="math inline">\(A \backslash \emptyset= A\)</span> * <span class="math inline">\(\emptyset \backslash A =\emptyset\)</span></p><h3 id="基本集合标记">基本集合标记</h3><ul><li><span class="math inline">\(\mathbb{N}\)</span>表示所有自然数的数集</li><li><span class="math inline">\(\mathbb{Z}\)</span>表示所有整数的数集</li><li><span class="math inline">\(\mathbb{Q}\)</span>表示所有有理数：<span class="math inline">\(\{\frac{a}{b} \mid  a,b \in\mathbb{Z},b \neq 0\}\)</span></li><li><span class="math inline">\(\mathbb{R}\)</span> 表示所有实数集</li><li><span class="math inline">\(\mathbb{C}\)</span> 表示所有复数集</li></ul><h3 id="笛卡尔积cartesian-product">笛卡尔积（Cartesian product）</h3><p>笛卡尔积，记作 <span class="math inline">\(A \timesB\)</span>，表示两个集合中的 元素的有序对，即：</p><p><span class="math inline">\(A \times B = \{(a,b) \mid a \in A,b \inB\}\)</span></p><h3 id="幂集">幂集</h3><p>幂集，就是原集合中所有的子集（包括全集和空集）构成的集。</p><p><span class="math inline">\(S: \{T | T \subseteq S\}\)</span></p><p>举个栗子，如果 <span class="math inline">\(S = \{1,2,3\}\)</span>,<span class="math inline">\(S\)</span>的幂集: <spanclass="math inline">\(P(S) =\{\emptyset,\{1\},\{2\},\{3\},\{1,2\},\{1,3\},\{2,3\},\{1,2,3\}\}\)</span>。</p><p>如果 <span class="math inline">\(\mid S \mid = k\)</span>，那么 <spanclass="math inline">\(\mid P(S) \mid = 2^k\)</span>。</p><h2 id="命题逻辑">命题逻辑</h2><h3 id="命题">命题</h3><p>能判断对错指代清楚的叫命题。例如： * 今天会下雨 * 根号三是无理数</p><h3 id="逻辑符号">逻辑符号</h3><ol type="1"><li>合取：记作 <span class="math inline">\(q \landp\)</span>，只有两个都为真，结果才为真。</li><li>析取：记作 <span class="math inline">\(q \lorp\)</span>，两个只要有一个真，结果就为真。</li><li>否定：记作 <span class="math inline">\(\lnot p\)</span>，p的否定，非 p。</li></ol><p>永真式：表示无论变量如何，永远为真的式子。例如：<spanclass="math inline">\(P \lor \lnot Q\)</span></p><p>矛盾式：表示无论变量如何，永远为假的式子。例如：<spanclass="math inline">\(P \land \lnot Q\)</span></p><table><thead><tr><th><span class="math inline">\(P\)</span></th><th><span class="math inline">\(Q\)</span></th><th><span class="math inline">\(P \land Q\)</span></th><th><span class="math inline">\(P \lor Q\)</span></th><th><span class="math inline">\(\lnot P\)</span></th></tr></thead><tbody><tr><td>T</td><td>T</td><td>T</td><td>T</td><td>F</td></tr><tr><td>T</td><td>F</td><td>F</td><td>T</td><td>F</td></tr><tr><td>F</td><td>T</td><td>F</td><td>T</td><td>T</td></tr><tr><td>F</td><td>F</td><td>F</td><td>F</td><td>T</td></tr></tbody></table><ol start="4" type="1"><li><p>蕴含式：<span class="math inline">\(P \implies Q\)</span>（P 蕴含Q），若 <span class="math inline">\(P\)</span> 为真，则 <spanclass="math inline">\(Q\)</span> 为真。</p><ul><li>简单关系：<span class="math inline">\((P \implies Q) \equiv (\lnot P\lor Q)\)</span>。</li><li>如果 <span class="math inline">\(P \implies Q\)</span> 和 <spanclass="math inline">\(Q \implies P\)</span> 都为真，记作 <spanclass="math inline">\(P \iff Q\)</span>，等价号。</li></ul></li></ol><p>已知 <span class="math inline">\(P \impliesQ\)</span>，我们可以定义： * 逆否命题为真：<spanclass="math inline">\(\lnot Q \implies \lnot P\)</span> * 逆命题：<spanclass="math inline">\(Q \implies P\)</span></p><table style="width:100%;"><colgroup><col style="width: 3%" /><col style="width: 3%" /><col style="width: 10%" /><col style="width: 10%" /><col style="width: 15%" /><col style="width: 15%" /><col style="width: 29%" /><col style="width: 12%" /></colgroup><thead><tr><th><span class="math inline">\(P\)</span></th><th><span class="math inline">\(Q\)</span></th><th><span class="math inline">\(\lnot P\)</span></th><th><span class="math inline">\(\lnot Q\)</span></th><th><span class="math inline">\(P \implies Q\)</span></th><th><span class="math inline">\(Q \implies P\)</span></th><th><span class="math inline">\(\lnot Q \implies \lnot P\)</span></th><th><span class="math inline">\(P \iff Q\)</span></th></tr></thead><tbody><tr><td>T</td><td>T</td><td>F</td><td>F</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>F</td><td>T</td><td>F</td><td>T</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>T</td><td>F</td><td>T</td><td>F</td><td>T</td><td>F</td></tr><tr><td>F</td><td>F</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr></tbody></table><h3 id="量词">量词</h3><p>全称量词：全称量词表示命题对所有元素都成立，通常用符号 <spanclass="math inline">\(\forall\)</span> 表示。</p><p>存在量词：存在量词表示命题对至少一个元素成立，通常用符号 <spanclass="math inline">\(\exists\)</span> 表示。</p><p>我们从高中用到大学，不再赘述了。</p><h3 id="处理否定的一些定律">处理否定的一些定律</h3><h4 id="德摩根定律">德摩根定律</h4><p><span class="math display">\[\lnot (P \land Q) \equiv (\lnot P \lor\lnot Q)\]</span> <span class="math display">\[\lnot (P \lor Q) \equiv(\lnot P \land \lnot Q)\]</span></p><h4 id="有关量词的一些定律">有关量词的一些定律</h4><p><span class="math inline">\(\lnot (\forall x P(x))\equiv \exists x\lnot P(x)\)</span></p><p><span class="math inline">\(\lnot (\exists x P(x))\equiv \forall x\lnot P(x)\)</span></p><p>下面还有更复杂一些的：</p><p><span class="math display">\[\lnot (\forall x \exists y P(x,y))\equiv \exists x \lnot(\exists y P(x,y))\equiv \exists x \forall y \lnot P(x,y)\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Discrete mathematics</category>
      
      <category>CS70</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Discrete mathematics</tag>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS50笔记（查漏补缺）</title>
    <link href="/2024/07/17/CS50%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%EF%BC%89/"/>
    <url>/2024/07/17/CS50%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>准备一个暑假在跑外卖的时候干点有用的事，就从学习CS50开始吧，正好学点自己不知道到的知识。</p><p><strong>2024-07-17~2024-08-17</strong>结束正好用时一个月，也终于结束了，因为不是零基础，所以有些课程跳了，有的太简单了，还是挺有感慨的，以前发现自己编程同龄人无敌，现在才发现任重道远，开学后要好好学学指针。</p><h2 id="并归排序">并归排序</h2><p>还是基础功不太扎实，连这个都不知道。</p><p>归并排序基于分治思想将数组分段排序后合并，主要思想是将两个<strong>已经排好序</strong>的数合并在一起。</p><ol type="1"><li><p>注意：这个算法必须申请<strong>至少两倍空间</strong>，首先，设定两个指针，这两个指针在两个已经排好的数组的起始位置。</p></li><li><p>合并：从左向右，枚举两个数组<code>a[i]</code>和<code>b[i]</code>，找出最小的数放入新数组，直到有一个数组为空时，把另一个数组的剩下的元素放入新数组。</p></li><li><p>分治：如果数组长度为1，该数组就是有序的，不用排序。如果数组长度大于1，此时应将该数组分为两段，等分成左边和右边，检查有无序，无序重复此操作，左边有序后检查右边，两变边都有序了，合并（见2操作）。</p></li></ol><p>给一张动图吧，好理解一些，网上的：<imgsrc="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif"alt="sort" /></p><h2 id="c-标准库-string.h">C 标准库 &lt;string.h&gt;</h2><h3 id="strcmp">strcmp()</h3><p><code>int strcmp(const char *str1, const char *str2)</code></p><p>str1 ------ 要进行比较的第一个字符串</p><p>str2 ------ 要进行比较的第二个字符串</p><p>返回值如下： * 如果返回值小于 0，则表示 str1 小于 str2。 *如果返回值大于 0，则表示 str1 大于 str2。 * 如果返回值等于 0，则表示str1 等于 str2。</p><h3 id="strcpy">strcpy()</h3><p><code>char *strcpy(char *dest, const char *src)</code></p><p>dest -- 指向用于存储复制内容的目标数组。<br />src -- 要复制的字符串。</p><h2 id="c-标准库-stdlib.h">C 标准库 &lt;stdlib.h&gt;</h2><h3 id="malloc">malloc()</h3><p>C 库函数 <code>void *malloc(size_t size)</code>分配所需的内存空间，并返回一个指向它的指针。</p><p><code>void *malloc(size_t size)</code></p><p>size -- 内存块的大小，以字节为单位。</p><h3 id="free">free()</h3><p>C 库函数 <code>void free(void *ptr)</code> 释放之前调用calloc、malloc 或 realloc 所分配的内存空间。</p><p><code>void free(void *ptr)</code></p><p>ptr -- 指针指向一个要释放内存的内存块，该内存块之前是通过调用malloc、calloc 或 realloc进行分配内存的。如果传递的参数是一个空指针，则不会执行任何动作。</p><p>C 标准库 &lt;stdio.h&gt;</p><h3 id="文件操作">文件操作</h3><h4 id="fopen">fopen()</h4><p>可以使用 fopen()函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE的一个对象，类型 FILE包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：</p><p><code>FILE *fopen( const char *filename, const char *mode );</code></p><p>filename ----- 字符串，用来命名文件。</p><p>mode --------- 访问模式，有下面几种格式：</p><table><colgroup><col style="width: 9%" /><col style="width: 90%" /></colgroup><thead><tr><th><strong>模式</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>r</td><td>打开一个已有的文本文件，允许读取文件。</td></tr><tr><td>w</td><td>打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td></tr><tr><td>a</td><td>打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td></tr><tr><td>r+</td><td>打开一个文本文件，允许读写文件。</td></tr><tr><td>w+</td><td>打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td></tr><tr><td>a+</td><td>打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td></tr></tbody></table><h4 id="fclose">fclose()</h4><p>为了关闭文件，请使用 fclose() 函数。函数的原型如下：</p><p><code>int fclose( FILE *fp );</code></p><p>如果成功关闭文件，fclose()函数返回零，如果关闭文件时发生错误，函数返回 EOF。</p><h4 id="fprintf">fprintf()</h4><p>函数 fprintf()函数根据指定的格式发送信息到由stream（流）指定的文件。因此 fprintf()可以使得信息输出到指定的文件。</p><p><code>int fprintf( FILE *stream, const char *format, ... );</code></p><p>第一个参数是文件指针，第二个和后面都和printf()一样的。将内容输出到字符串中。</p><h4 id="fread">fread()</h4><p>C 库函数 size_t fread(void <em>ptr, size_t size, size_t nmemb, FILE</em>stream) 从给定流 stream 读取数据到 ptr 所指向的数组中。</p><p><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</code></p><p>参数：</p><ul><li>ptr -- 这是指向带有最小尺寸 size*nmemb 字节的内存块的指针。</li><li>size -- 这是要读取的每个元素的大小，以字节为单位。</li><li>nmemb -- 这是元素的个数，每个元素的大小为 size 字节。</li><li>stream -- 这是指向 FILE 对象的指针，该 FILE对象指定了一个输入流。</li></ul><h2 id="sql">SQL</h2><h3 id="select">SELECT</h3><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name;<br></code></pre></div></td></tr></table></figure><ul><li><p><strong>column1, column2,...</strong>：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。</p></li><li><p><strong>table_name</strong>：要查询的表名称。</p></li><li><p>注意：在 <code>SELECT</code> 后在加 <code>DISTINCT</code>可以去重</p></li></ul><h3 id="where">WHERE</h3><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br></code></pre></div></td></tr></table></figure><p>WHERE 相当于 if ，<code>condition</code> 是条件。</p><h4 id="order-by">ORDER BY</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column1, column2, ... <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>;<br></code></pre></div></td></tr></table></figure><ul><li><strong>column1, column2,...</strong>：要排序的字段名称，可以为多个字段。</li><li><strong>ASC</strong>：表示按升序排序。</li><li><strong>DESC</strong>：表示按降序排序。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CS50</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>SQL</tag>
      
      <tag>Python</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 库 Matplotlib 学习</title>
    <link href="/2024/05/22/Python%E5%BA%93Matplotlib%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/05/22/Python%E5%BA%93Matplotlib%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>在数学建模选拔赛中需要写一点画个图，秉承着需要啥就学啥的原则，来学一点Python中的强大的库</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>画图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git 学习（长期）</title>
    <link href="/2024/05/02/git%E5%AD%A6%E4%B9%A0%EF%BC%88%E9%95%BF%E6%9C%9F%EF%BC%89/"/>
    <url>/2024/05/02/git%E5%AD%A6%E4%B9%A0%EF%BC%88%E9%95%BF%E6%9C%9F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="git">Git</h1><h2 id="背景">背景</h2><p>最经换电脑了，电脑里的东西全得转移，真的麻烦，搞这个博客就花了好长时间来git，借此机会想来学习一下 git 相关知识，慢慢学。</p><h2 id="版本控制系统">版本控制系统</h2><ol type="1"><li><p>集中式版本控制系统：</p><p>集中式的版本控制系统，所有的版本库是放在中央服务器中的，也就是说我们每一次的修改上传都是保存在中央服务器中的。中央服务器就是个大仓库，大家把产品都堆里面，每一次需要改进和完善的时候，需要去仓库里面把文件给提出来，然后再操作。</p><p>但是有缺点，如果主服务器出现了问题，所有人就无法上传或下载，而且会有延迟，可能下载下来的版本不是最新的。</p></li><li><p>分布式版本控制系统：分布的含义不是说每台计算机上只留有版本库的一部分。恰恰相反，分布的含义是每台计算机上都还有一个完整的版本库。这个时候，你的修改仅仅需要提交给本地的版本库进行保存就可以了。</p><p>而 Git 就是一个优秀分布式版本控制系统。</p></li></ol><h2 id="新建仓库">新建仓库</h2><p>一共有两种，第一种就是直接在自己本地电脑上新建一个，第二种就是从远程服务器克隆一个仓库。</p><p>方式一：<code>git init</code></p><p>方式二：<code>git clone</code></p><p>不管是哪样，都会在本地文件夹中生成一个 <code>.git</code>目录，这个目录中存放着许多有关git信息的重要文件。</p><p>...... 未完待续</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 学习 1</title>
    <link href="/2022/08/08/Linux-%E5%AD%A6%E4%B9%A0-1/"/>
    <url>/2022/08/08/Linux-%E5%AD%A6%E4%B9%A0-1/</url>
    
    <content type="html"><![CDATA[<h1 id="linux-文件权限学习">Linux 文件权限学习</h1><h2 id="用户与用户组">用户与用户组</h2><ol type="1"><li><p>文件拥有者(root)</p></li><li><p>一般用户组</p></li><li><p>其他人</p></li></ol><h2 id="文件权限">文件权限</h2><p>在终端输入 <code>ls -al</code>后，就会出现一堆东西，其中在每一行的前面的是文件的权限，共有10个字符，</p><ul><li><p>第一个字符代表这个文件是目录、文件或链接文件。</p><ul><li><p><code>d</code> 则是目录</p></li><li><p><code>-</code> 则是文件</p></li><li><p><code>l</code> 则是链接文件</p></li></ul></li><li><p>接下来三个为一组，共三组；其中 <code>r</code>表示可读，<code>w</code> 表示可写，<code>x</code> 表示可执行</p><ul><li><p>第一组 <strong>文件拥有者(root)</strong> 可具备的权限</p></li><li><p>第二组 <strong>一般用户</strong> 的权限</p></li><li><p>第三组 <strong>没有加入本用户组的其他账号</strong>的权限</p></li></ul></li></ul><h2 id="修改文件属性">修改文件属性</h2><ul><li><p><code>chgrp</code></p><ul><li><p>修改文件所属用户组</p></li><li><p>参数 <code>-R</code> ：进行递归修改</p></li><li><p>语法：<code>chgrp [-R][user] dir/file</code></p></li></ul></li><li><p><code>chown</code></p><ul><li><p>修改文件拥有者</p></li><li><p>语法：<code>chown [-R] [owner][:group] file</code></p></li></ul></li><li><p><code>chmod</code></p><ul><li><p>修改权限</p></li><li><p>数字类型修改权限：<code>r=4,w=2,x=1</code>，每种身份的的权限需要累加的，例如<code>owner=rwx=4+2+1=7,group=rwx=4+2+1=7,others=0+0+0=0</code>，所以权限数字是770，</p></li><li><p>符号类型修改权限：身份<code>u=user,g=group,o=others</code>，<code>+(加入),-(移除),=(设置)</code></p></li><li><p>语法：<code>chmod [-R] [xyz] file/dir</code> 或者<code>chmod [ugo...][[+-=][rwxX]] file/dir</code></p></li></ul></li></ul><h2 id="目录与文件的权限意义">目录与文件的权限意义</h2><h3 id="权限对文件的重要性">权限对文件的重要性</h3><ul><li><p>r(read)：可读取此文件的实际内容</p></li><li><p>w(write)：可以编辑，修改此文件的内容</p></li><li><p>x(execute)：该文件具有被系统执行的权限</p></li></ul><p>注意，文件是否能被执行，与文件名后缀无关，与 x 权限有关，记得与Windows 区分开</p><p>有 w 权限，但并不具备有删除文件本身的权限</p><h3 id="权限对目录的重要性">权限对目录的重要性</h3><ul><li><p>r：具有读取目录结构的权限</p></li><li><p>w：改动该目录结构列表的权限</p></li><li><p>x：用户能否进入该目录成为工作目录（目前所在的目录）</p></li></ul><p>开放目录给任何人看时，应该至少给予 r 或 x 的权限。</p><p>先这样吧，有时间在来整理。</p>]]></content>
    
    
    <categories>
      
      <category>学习随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Python opencv 缩放图像</title>
    <link href="/2022/04/29/%E4%BD%BF%E7%94%A8-Python-opencv-%E7%BC%A9%E6%94%BE%E5%9B%BE%E5%83%8F/"/>
    <url>/2022/04/29/%E4%BD%BF%E7%94%A8-Python-opencv-%E7%BC%A9%E6%94%BE%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<p>突发奇想来用 Python 来缩放图像，搜到可以用 opencv来实现功能，就稍微了解一下，当然 opencv 的功能不只这些。</p><p><strong>注意</strong>：此处所有 <code>cv</code> 在实际写时改成<code>cv2</code> 或者在导入库时加入一句<code>import cv2 as cv</code></p><h2 id="基本功能">基本功能</h2><h3 id="读取图像">读取图像</h3><p>可以用 <code>cv.imread()</code>来读取图像，一共有两个参数，第一个提供图片所在目录，第二个是一个标志，表示读取的方式：</p><ul><li><p>cv.IMREAD_COLOR ：加载彩色图像，默认</p></li><li><p>cv.IMREAD_GRAYSCALE：以灰度模式加载图像</p></li><li><p>cv.IMREAD_UNCHANGED：加载图像</p></li></ul><p><strong>注意</strong>：即使图像路径错误，它也不会引发任何错误，但是<code>print img</code> 会给出 <code>None</code></p><h3 id="显示图像">显示图像</h3><p>使用函数 <code>cv.imshow()</code>在窗口上显示图像，窗口自动适合图像尺寸。</p><p>第一个参数是字符串，表示窗口名，第二个参数是我们需要显示的图片的参数。</p><p>一般配合以下函数使用：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">cv.imshow(<span class="hljs-string">&#x27;img&#x27;</span>,img)<br>cv.waitKey(<span class="hljs-number">0</span>)<br>cv.destoryAllWindows()<br></code></pre></div></td></tr></table></figure><p><code>cv.waitKey()</code>是一个控制键盘的函数。其参数是以毫秒为单位的时间。如果您在这段时间内按下任何键，程序将继续运行。如果<code>0</code> 被传递，它将无限期地等待一次敲击键。</p><h3 id="写入图像">写入图像</h3><p>使用 <code>cv.imwrite()</code>保存图像，第一个参数是文件名，第二个参数是要保存的图像。</p><h3 id="缩放">缩放</h3><p>使用函数 <code>cv.resize()</code>：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">resize(src, dsize, dst=<span class="hljs-literal">None</span>, fx=<span class="hljs-literal">None</span>, fy=<span class="hljs-literal">None</span>, interpolation=<span class="hljs-literal">None</span>)<br></code></pre></div></td></tr></table></figure><p><code>scr</code>：是需要缩放的图片的对象</p><p><code>dsize</code>：目标图像大小。当 dsize 为 0时，通过以下公式计算得出：</p><ul><li><code>disize = Size(round(fx*scr.cols) , round(fy*src.rows))</code></li></ul><p>所以 <code>disze</code> 与 <code>(fx , fy)</code> 不能同时为 0</p><p><code>fx,fy</code>：水平和垂直轴的比例因子。当它为零时，计算公式如下：<code>(double)dsize.width/src.cols</code>和 <code>(double)dsize.width/src.cols</code></p><p><code>interpolation</code> ：插值方法，具体我也不太懂，最好使用<code>cv.INTER_LINEAR</code> 参数</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Distant-Skys</span><br><span class="hljs-comment"># To make a picture smaller or bigger.</span><br><br><span class="hljs-keyword">import</span> cv2 <span class="hljs-keyword">as</span> cv<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>image = cv.imread(<span class="hljs-string">&#x27;1.jpg&#x27;</span>)<br><br>res = cv.resize(image,<span class="hljs-literal">None</span>,fx=<span class="hljs-number">0.7</span>,fy=<span class="hljs-number">0.7</span>,interpolation=cv.INTER_CUBIC)<br><span class="hljs-comment"># if want to make picture bigger ,let ((fx and fy) &gt; 1).</span><br><br><span class="hljs-comment"># print the result picture.</span><br><span class="hljs-comment"># cv.imshow(&#x27;result image&#x27;,res)</span><br><span class="hljs-comment"># cv.waitKey(0)</span><br><span class="hljs-comment"># cv.destroyAllWindows()</span><br><br>cv.imwrite(<span class="hljs-string">&#x27;1_result.jpg&#x27;</span>,res)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习笔记</title>
    <link href="/2022/01/29/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/01/29/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="java-学习">Java 学习</h1><ul><li><p>Java 的<strong>基本</strong>模板：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-comment">// Do somethings;</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>Java 的输入不是像 c++一样有简单的函数，而是先要创建一个输入类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Scanner cin = <span class="hljs-keyword">new</span> Scanner(System.in);<br></code></pre></div></td></tr></table></figure><p>读入的话，可以使用其中的方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">n = cin.next();<br><span class="hljs-comment">// 可以读到下一个空格之前</span><br>n = cin.nextLine();<br><span class="hljs-comment">// 可以读一整行</span><br></code></pre></div></td></tr></table></figure><p><strong>注意</strong>：<code>cin.next()</code>不能读带有空格的字符串，<code>cin.nextLine()</code>可以读带有空格的字符串，也可以获得空白。</p><p>当然，int 和 float 有 <code>nextInt()</code> <code>nextFloat()</code>。读入之前最好用 <code>hasNextInt()</code> <code>hasNextFloat()</code> 来验证。</p></li><li><p>Java 的输出较为简单：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">System.out.println(n);    <span class="hljs-comment">// 输出完换行</span><br>System.out.print(n);    <span class="hljs-comment">// 输出完不换行</span><br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ABC235E-MST+1题解</title>
    <link href="/2022/01/29/ABC235E-MST-1%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/01/29/ABC235E-MST-1%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="abc235e-mst1-题解">ABC235E MST+1 题解</h1><h2 id="题目大意">题目大意</h2><p>给你一个图 <span class="math inline">\(G\)</span> 含有 <spanclass="math inline">\(n\)</span> 个顶点和 <spanclass="math inline">\(m\)</span> 条边，给出 <spanclass="math inline">\(Q\)</span> 次询问，询问所多输入的边加上原图 <spanclass="math inline">\(G\)</span> 的最小生成树是否是存在 <spanclass="math inline">\(e_i\)</span>，存在输出 <code>Yes</code> 不存在输出<code>No</code>。</p><h2 id="思路">思路</h2><p>首先我们可以想到用最简单的方法，在每次询问时都做一次 Kruskal算法，如果这个边被取到了，那么输出<code>Yes</code>，反之亦然。时间复杂度为 <spanclass="math inline">\(\mathcal{O}(Q \times n  \logn)\)</span>，太慢。</p><p>因为每个询问是相互独立的，而且询问的边 <spanclass="math inline">\(e_i\)</span> 对于 并查集的不会产生影响，所以可以想到只用一次 Kruskal算法，把所有的边都涵盖上。</p><p>在遍历时每条边的处理方法：</p><ul><li><p>如果是询问的 <span class="math inline">\(e_i\)</span> 的边</p><ul><li><p>如果 <span class="math inline">\(e_i\)</span> 的所连的两个顶点<span class="math inline">\(u,v\)</span> 没有连通，则标记为<code>Yes</code>。</p></li><li><p>如果连通，则标记为 <code>No</code>。</p></li></ul></li><li><p>如果是询问的 <span class="math inline">\(e_i\)</span> 的边</p><ul><li><p>如果 <span class="math inline">\(e_i\)</span> 的所连的两个顶点<span class="math inline">\(u,v\)</span> 没有连通，则标记为<code>Yes</code>。</p></li><li><p>如果连通，则标记为 <code>No</code>。</p></li></ul></li><li><p>如果是 <span class="math inline">\(G\)</span> 的边        </p><ul><li>将两个顶点在并查集内合并</li></ul></li></ul><p>时间复杂度 <span class="math inline">\(\mathcal{O}((n+Q) \log (n +Q))\)</span>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">200005</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><span class="hljs-keyword">int</span> u,v,w,Is,num;&#125;;<br><span class="hljs-keyword">int</span> fa[maxn];<br>Edge e[maxn*<span class="hljs-number">2</span>];<br><span class="hljs-keyword">bool</span> ans[maxn];<br><span class="hljs-keyword">int</span> n,m,q;<br>vector&lt;Edge&gt; qe;<br><br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> ==(<span class="hljs-keyword">const</span> Edge &amp;a,<span class="hljs-keyword">const</span> Edge &amp;b)&#123;<span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (a.u == b.u &amp;&amp; a.v == b.v &amp;&amp; a.w == b.w);&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">found</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">found</span>(fa[x]);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Edge x,Edge y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x.w &lt; y.w;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init_Onion</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;x++)    fa[x] = x;<br>    <span class="hljs-built_in">memset</span>(ans,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ans));<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);<br>        e[i].Is = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;e[m+i].u,&amp;e[m+i].v,&amp;e[m+i].w);<br>        e[m+i].Is = <span class="hljs-number">1</span>;e[m+i].num = i;<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+m+q+<span class="hljs-number">1</span>,cmp);<br>    <span class="hljs-built_in">Init_Onion</span>();<br><br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m+q;i++)&#123;<br>        <span class="hljs-keyword">if</span>(e[i].Is == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">found</span>(e[i].v) != <span class="hljs-built_in">found</span>(e[i].u))<br>                ans[e[i].num] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> u = e[i].u,v = e[i].v;<br>        <span class="hljs-keyword">int</span> f = <span class="hljs-built_in">found</span>(u),t = <span class="hljs-built_in">found</span>(v);<br>        fa[t] = f;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;<br>        <span class="hljs-keyword">if</span>(ans[i] == <span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Atcoder</tag>
      
      <tag>Kruskal</tag>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ATCoder ABC 001</title>
    <link href="/2021/11/06/ATCoder-ABC-001/"/>
    <url>/2021/11/06/ATCoder-ABC-001/</url>
    
    <content type="html"><![CDATA[<h1 id="atcoder-abc-001">ATCoder ABC 001</h1><p><a href="https://atcoder.jp/contests/abc001/tasks">题目链接</a></p><h2 id="a-题">A 题</h2><p>太简单了，不放代码了。</p><h2 id="b-题">B 题</h2><p>其实，就是模拟，只是需要注意边界问题，是一个左开右闭的区间。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> m;<br><br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">0</span> &amp;&amp; m &lt;= <span class="hljs-number">5000</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">1000</span>)<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; (<span class="hljs-number">10</span> * m) / <span class="hljs-number">1000</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; (<span class="hljs-number">10</span> * m) / <span class="hljs-number">1000</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">5000</span> &amp;&amp; m &lt;= <span class="hljs-number">30000</span>)<br>        cout &lt;&lt; m / <span class="hljs-number">1000</span> + <span class="hljs-number">50</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">30000</span> &amp;&amp; m &lt;= <span class="hljs-number">70000</span>)<br>        cout &lt;&lt; (m / <span class="hljs-number">1000</span> - <span class="hljs-number">30</span>) / <span class="hljs-number">5</span> + <span class="hljs-number">80</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-number">89</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="c-题">C 题</h2><p>同样是模拟，只是 <code>else if</code>的数量有点多，注意边界，同上。</p><p>这道题目需要求一个保留两位小数的浮点数，所以需要自己手写函数<code>Around</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Around</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x,<span class="hljs-keyword">double</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">floor</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,k)*x+<span class="hljs-number">0.5</span>) / <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,k);<br>    <span class="hljs-comment">// 保留两位小数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    <span class="hljs-keyword">int</span> cmp,meter;<span class="hljs-keyword">double</span> speed,sid;<br>    cin&gt;&gt;sid&gt;&gt;meter;<br>    speed = meter / <span class="hljs-number">60.0</span>;<br>    speed = <span class="hljs-built_in">Around</span>(speed,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">112.5</span> &amp;&amp; sid &lt;= <span class="hljs-number">337.5</span>)        s = <span class="hljs-string">&quot;NNE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">337.5</span> &amp;&amp; sid &lt; <span class="hljs-number">562.5</span>)    s = <span class="hljs-string">&quot;NE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">562.5</span> &amp;&amp; sid &lt; <span class="hljs-number">787.5</span>)    s = <span class="hljs-string">&quot;ENE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">787.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1012.5</span>)    s = <span class="hljs-string">&quot;E&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1012.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1237.5</span>)    s = <span class="hljs-string">&quot;ESE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1237.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1462.5</span>)    s = <span class="hljs-string">&quot;SE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1462.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1687.5</span>)    s = <span class="hljs-string">&quot;SSE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1687.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1912.5</span>)    s = <span class="hljs-string">&quot;S&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1912.5</span> &amp;&amp; sid &lt; <span class="hljs-number">2137.5</span>)    s = <span class="hljs-string">&quot;SSW&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">2137.5</span> &amp;&amp; sid &lt; <span class="hljs-number">2362.5</span>)    s = <span class="hljs-string">&quot;SW&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">2362.5</span> &amp;&amp; sid &lt; <span class="hljs-number">2587.5</span>)    s = <span class="hljs-string">&quot;WSW&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">2587.5</span> &amp;&amp; sid &lt; <span class="hljs-number">2812.5</span>)    s = <span class="hljs-string">&quot;W&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">2812.5</span> &amp;&amp; sid &lt; <span class="hljs-number">3037.5</span>)    s = <span class="hljs-string">&quot;WNW&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">3037.5</span> &amp;&amp; sid &lt; <span class="hljs-number">3262.5</span>)    s = <span class="hljs-string">&quot;NW&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">3262.5</span> &amp;&amp; sid &lt; <span class="hljs-number">3487.5</span>)    s = <span class="hljs-string">&quot;NNW&quot;</span>;<br>    <span class="hljs-keyword">else</span>    s = <span class="hljs-string">&quot;N&quot;</span>;<br><br>    <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">0.0</span> &amp;&amp; speed &lt;= <span class="hljs-number">0.2</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C 0\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">0.3</span> &amp;&amp; speed &lt;= <span class="hljs-number">1.5</span>)    cmp = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">1.6</span> &amp;&amp; speed &lt;= <span class="hljs-number">3.3</span>)    cmp = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">3.4</span> &amp;&amp; speed &lt;= <span class="hljs-number">5.4</span>)    cmp = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">5.5</span> &amp;&amp; speed &lt;= <span class="hljs-number">7.9</span>)    cmp = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">8.0</span> &amp;&amp; speed &lt;= <span class="hljs-number">10.7</span>)    cmp = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">10.8</span> &amp;&amp; speed &lt;= <span class="hljs-number">13.8</span>)    cmp = <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">13.9</span> &amp;&amp; speed &lt;= <span class="hljs-number">17.1</span>)    cmp = <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">17.2</span> &amp;&amp; speed &lt;= <span class="hljs-number">20.7</span>)    cmp = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">20.8</span> &amp;&amp; speed &lt;= <span class="hljs-number">24.4</span>)    cmp = <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">24.5</span> &amp;&amp; speed &lt;= <span class="hljs-number">28.4</span>)    cmp = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">28.5</span> &amp;&amp; speed &lt;= <span class="hljs-number">32.6</span>)    cmp = <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">else</span>    cmp = <span class="hljs-number">12</span>;<br><br><br>    cout&lt;&lt;s&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cmp&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="d-题">D 题</h2><p>比较简单的思维题。</p><p>输入时，注意时间为 5 分钟为增量舍入时间，观察题目发现时间总是从 <spanclass="math inline">\(0000 \Rightarrow9999\)</span>。所以可以想到开一个桶，第 <spanclass="math inline">\(i\)</span> 个桶表示第 <spanclass="math inline">\(i\)</span>个时间是否有雨。最后重新遍历一次桶，记录下开始和结束的节点并输入。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">110000</span>;<br><span class="hljs-keyword">int</span> g[maxn];<br><span class="hljs-keyword">int</span> t;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)&#123;<br>        <span class="hljs-keyword">int</span> x,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d-%d&quot;</span>,&amp;x,&amp;y);<br>        x -= (x%<span class="hljs-number">5</span>);y += (<span class="hljs-number">5</span> - y%<span class="hljs-number">5</span>) % <span class="hljs-number">5</span>;<br>        <span class="hljs-comment">// cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span><br>        <span class="hljs-keyword">if</span>(y%<span class="hljs-number">100</span>&gt;=<span class="hljs-number">60</span>)&#123;<br>            y+=<span class="hljs-number">100</span>;<br>            y-=<span class="hljs-number">60</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=x;j&lt;y;j++)    g[j] ++;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> on=<span class="hljs-number">0</span>,be=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">110000</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(g[i])&#123;<br>            <span class="hljs-keyword">if</span>(!on)be=i;<br>            on=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(on)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d-%04d\n&quot;</span>,be,i);<br>            on=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ATCoder</tag>
      
      <tag>简单题</tag>
      
      <tag>模拟</tag>
      
      <tag>思维题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2021/10/06/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2021/10/06/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集">并查集</h1><figure><img src="https://z3.ax1x.com/2021/10/06/4x2h9K.png" alt="并查集" /><figcaption aria-hidden="true">并查集</figcaption></figure><p>并查集是一种树形的数据结构，可以很高效的解决一些问题。</p><h2 id="操作">操作</h2><p>有三个操作：</p><ul><li>初始化</li><li>查找</li><li>合并</li></ul><h2 id="初始化">初始化</h2><p>初始时，每个点都是自己的父亲。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> fa[maxn];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)<br>    fa[i] = i;<br></code></pre></div></td></tr></table></figure><h3 id="查找">查找</h3><p><img src="https://z3.ax1x.com/2021/10/06/4xWYiq.png" /></p><p>上图中，想要找 <span class="math inline">\(5\)</span> 的祖先，先通过<span class="math inline">\(2-5\)</span> 这条边找到 <spanclass="math inline">\(2\)</span> ，通过同样的办法找到祖先 <spanclass="math inline">\(1\)</span>，<span class="math inline">\(1\)</span>没有祖先就得到答案了。<br />就像上面一样递归找到每个点的祖先，在返回答案。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x == fa[x])<span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="合并">合并</h3><p>显而易见，就是将两个集合合并。</p><figure><img src="https://z3.ax1x.com/2021/10/06/4zwqgA.png" alt="union" /><figcaption aria-hidden="true">union</figcaption></figure><p>挺简单的，就直接上代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">int</span> u = <span class="hljs-built_in">find</span>(x),v = <span class="hljs-built_in">find</span>(v);<br>    fa[u] = v;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>设操作次数为 <span class="math inline">\(m\)</span>，平均时间复杂度为<span class="math inline">\(\mathcal{O}(m \logn)\)</span>，最坏时间复杂度为 <spanclass="math inline">\(\mathcal{O}(mn)\)</span>。</p><h2 id="优化">优化</h2><p>在上面的操作中还是不够快，所以我们想办法优化。</p><h3 id="路径压缩">路径压缩</h3><p>如果一个关系像一条链（如下图）一样，那么查找最下面的数的祖先的时间复杂度得退化到<span class="math inline">\(\mathcal{O}(n)\)</span> 。</p><figure><img src="https://z3.ax1x.com/2021/10/06/4z0LiF.png" alt="chain" /><figcaption aria-hidden="true">chain</figcaption></figure><p>这样一层一层找太浪费时间，直接当祖先的儿子，问一次就可以出结果了。甚至祖先是谁都无所谓，只要这个人可以代表我们家族就能得到想要的效果。<strong>把在路径上的每个节点都直接连接到根上</strong>。</p><p><em>代码</em>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="启发式合并">启发式合并</h3><p>查找都优化了，那合并总不能不优化吧。</p><p>我们思考一个问题：如果一个点与一个含有 <spanclass="math inline">\(100\)</span> 个点的集合合并，是一个点合并到 <spanclass="math inline">\(100\)</span> 个点的集合快？还是 <spanclass="math inline">\(100\)</span>个点合并到一个点快？答案是显然的。<br />在题目中我们通常维护 点数 或 深度 来作为估价函数来合并</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">int</span> u = <span class="hljs-built_in">find</span>(x),v = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(sz[u] &gt; sz[v])<br>        <span class="hljs-built_in">swap</span>(u，v);<br>    fa[u] = v;<br>    sz[v] += sz[u];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="优化后的时间复杂度">优化后的时间复杂度</h3><ul><li>只使用路径压缩的平均时间复杂度为 <spanclass="math inline">\(\mathcal{O}(m\alpha(n))\)</span>，最坏时间复杂度为 <spanclass="math inline">\(\mathcal{O}(m \log n)\)</span></li><li>只使用启发式合并的平均时间复杂度为 <spanclass="math inline">\(\mathcal{O}(m \log n)\)</span>，最坏时间复杂度为<span class="math inline">\(\mathcal{O}(m \log n)\)</span>。</li><li>路径压缩 + 启发式合并的平均时间复杂度为 <spanclass="math inline">\(\mathcal{O}(m\alpha(n))\)</span>，最坏时间复杂度为 <spanclass="math inline">\(\mathcal{O}(m \alpha(n))\)</span>。</li></ul><p>这里 <span class="math inline">\(\alpha(n)\)</span>表示阿克曼函数的反函数增长很慢，可以认为是常数(<ahref="https://oi-wiki.org/ds/dsu/#_7">具体在这</a>)。</p><h2 id="应用">应用</h2><h3 id="带权并查集">带权并查集</h3><p>我们可以在并查集上维护一些东西，比如元素和，元素个数。</p><p>比如说<a href="https://www.luogu.com.cn/problem/UVA11987">AlmostUnion-Find</a>这道题。它就是在并查集上维护一个元素和与元素个数，唯一不同的是这道题要一个虚点并查集，防止在第二个操作中下面的元素一起移动。</p><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br> fa[i] = n+i;<br>        <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n+<span class="hljs-number">1</span>;i&lt;=n+n;i++)<br>fa[i] = i,sz[i] = <span class="hljs-number">1</span>,sum[i] = i-n;<br><br><span class="hljs-comment">// 第二个操作，仅仅将一个节点移动到另一个集合上。</span><br><br><span class="hljs-keyword">int</span> u = <span class="hljs-built_in">find</span>(x),v = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(u != v)&#123;<br>fa[x] = v;<br>sz[u] --;sz[v] ++;<br>sum[u] -= x;sum[v] += x;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵</title>
    <link href="/2021/09/18/%E7%9F%A9%E9%98%B5/"/>
    <url>/2021/09/18/%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="矩阵">矩阵</h1><h2 id="定义">定义</h2><p>在数学中，矩阵（Matrix）是一个按照长方阵列排列的复数或实数集合。</p><p>就像下面一样：</p><p><span class="math display">\[\begin{bmatrix}    1&amp;2&amp;3\\1&amp;2&amp;3\end{bmatrix}\]</span></p><p>特别的，主对角线上为 1，其余位置为 0 的叫做单位矩阵 <spanclass="math inline">\(I\)</span>：</p><p><span class="math display">\[\begin{bmatrix}    1&amp;0&amp;\cdots&amp;0\\    \vdots&amp;1&amp;\ddots&amp;0\\    0&amp;0&amp;\dots&amp;1\\\end{bmatrix}\]</span></p><h2 id="矩阵的运算">矩阵的运算</h2><p>矩阵的加减法是逐个元素进行的。</p><h3 id="乘法">乘法</h3><p>矩阵相乘只有在第一个矩阵的列数和第二个矩阵的行数相同时才有意义。</p><p>设 <span class="math inline">\(P\)</span> 为 <spanclass="math inline">\(M \times N\)</span> 的矩阵，<spanclass="math inline">\(Q\)</span> 是 <span class="math inline">\(N \timesQ\)</span> 的矩阵，<span class="math inline">\(C\)</span> 矩阵为 <spanclass="math inline">\(C = PQ\)</span>，则 <spanclass="math inline">\(C\)</span> 矩阵上 <spanclass="math inline">\(i\)</span> 行 <spanclass="math inline">\(j\)</span> 列的元素为。</p><p><span class="math display">\[c_{i,j} =\sum\limits_{k=1}^{M}P_{i,k}Q_{k,j}\]</span></p><p>没有看懂，没事，有一种<del>比较简单</del>的方法。</p><p>设 <span class="math inline">\(A\)</span> 矩阵为:</p><p><span class="math display">\[\begin{bmatrix}    a&amp;b\\    c&amp;d\\\end{bmatrix}\]</span></p><p>设 <span class="math inline">\(B\)</span> 矩阵为:</p><p><span class="math display">\[\begin{bmatrix}    e\\f\end{bmatrix}\]</span></p><p>所以 <span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 的乘积是：</p><p><span class="math display">\[e\begin{bmatrix}    a\\c\end{bmatrix} + f\begin{bmatrix}    b\\d\end{bmatrix}\]</span></p><p>注意，<strong>矩阵乘法满足结合律，不满足一般的交换律</strong>。</p><p>给出一个封装好的矩阵乘法：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mat</span>&#123;</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c[N][N];<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unit</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   c[i][i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mat</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));&#125;<br><span class="hljs-keyword">inline</span> mat <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> mat &amp;M)&#123;<br>mat ans;<br><span class="hljs-built_in">memset</span>(ans.c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ans.c);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>ans.c[i][j] += (c[i][k] * M.c[k][j]) % P,ans.c[i][j] %= P;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>如果算一个矩阵的 <spanclass="math inline">\(A^k\)</span>，可以使用快速幂来加速到 <spanclass="math inline">\(\mathcal{O}(n^3 \log k)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 快速幂</span><br><span class="hljs-function">mat <span class="hljs-title">qpow</span><span class="hljs-params">(mat x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    mat ans.<span class="hljs-built_in">unit</span>();<br>    <span class="hljs-keyword">while</span>(y &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(y % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            ans = ans * x;<br>        y = y / <span class="hljs-number">2</span>;<br>        x = x * x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="矩阵的应用">矩阵的应用</h2><h3 id="快速求斐波拉契数列">快速求斐波拉契数列</h3><p>斐波拉契数列形如： <span class="math display">\[F_1 = F_2 = 1,F_i =F_{i-1} + F_{i-2}  (i  \geq 3)\]</span><br />当然可以使用递推的方法来求，时间复杂度 <spanclass="math inline">\(\mathcal{O}(n)\)</span> ，还挺快。 但是遇到<ahref="https://www.luogu.com.cn/problem/P1962">这道题目</a>就不行了，<spanclass="math inline">\(2^{63}\)</span> 绝对会TLE，所以可以用矩阵加速递推。</p><p>我们可以设 <span class="math display">\[f(n) = \begin{bmatrix}F_{n}&amp; F_{n-1}\end{bmatrix}\]</span> ，我们希望可以从 <spanclass="math inline">\(f(n-1)\)</span> 推出它。</p><p>正好我们之前学了矩阵的乘法，所以我们可以尝试设一个矩阵 <spanclass="math inline">\(\text{base}\)</span> ，使得 <spanclass="math inline">\(f(n) = \text{base} \timesf(n-1)\)</span>，也就是：</p><p><span class="math display">\[ \begin{bmatrix}F_i &amp; F_{i-1}\end{bmatrix} = \text{base} \times\begin{bmatrix}F_{i-1} &amp; F_{i-2}\end{bmatrix}\]</span></p><p>因为前后都是 <span class="math inline">\(1 \times 2\)</span>的矩阵，所以可以知道 <span class="math inline">\(\text{base}\)</span>矩阵是 <span class="math inline">\(2 \times 2\)</span> 的矩阵。</p><p>所以 <span class="math inline">\(\text{base} = \begin{bmatrix}a &amp; b \\c &amp; d \\\end{bmatrix}\)</span></p><p>所以等式转化为：</p><p><span class="math display">\[\begin{bmatrix}F_i &amp; F_{i-1}\end{bmatrix} =F_{i-1} \times \begin{bmatrix}a &amp; b\end{bmatrix} + F_{i-2} \times\begin{bmatrix}c &amp; d\end{bmatrix}\]</span></p><p><span class="math display">\[\begin{bmatrix}F_i &amp; F_{i-1}\end{bmatrix} =\begin{bmatrix}a F_{i-1} + c F_{i-2}  &amp; b F_{i-1} + d F_{i-2}\end{bmatrix}\]</span></p><p>又因为 <span class="math display">\[F_i = F_{i-1} +F_{i-2}\]</span>，所以 <span class="math display">\[a = 1,c = 1,b = 1,d= 0\]</span>。</p><p>综上所述， <span class="math display">\[\text{base} = \begin{bmatrix}1 &amp; 1\\1 &amp; 0\end{bmatrix}\]</span>。</p><p>那么因为初始项为 <span class="math inline">\(F_1,F_2\)</span>。所以<span class="math inline">\(F_n = \begin{bmatrix} F_1 &amp; F_2\end{bmatrix} \times \text{base}^{n-2}\)</span></p><p>好好品品。</p><p><span class="math inline">\(\text{base}^{n-2}\)</span>矩阵可以通过上面的快速幂来求，所以时间复杂度为 <spanclass="math inline">\(\mathcal{O}(\log n)\)</span>。</p><p>这题核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mat</span>&#123;</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><span class="hljs-built_in">mat</span>() &#123;<span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));&#125;<br><span class="hljs-keyword">inline</span> mat <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> mat&amp; M)&#123;<br>mat res;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>;j++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">2</span>;k++)<br>res.c[i][j] = (res.c[i][j] + c[i][k]*M.c[k][j]) % mod;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;;<br><br>mat base,ans;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>base.c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = base.c[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = base.c[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>ans.c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = ans.c[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> y)</span></span>&#123;<br><span class="hljs-keyword">while</span>(y &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(y % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>ans = ans * base;<br>y = y / <span class="hljs-number">2</span>;<br>base = base * base;<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>其实矩阵可以干事情的很多，就写这么多吧。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习线段树总结</title>
    <link href="/2021/08/22/%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%80%BB%E7%BB%93/"/>
    <url>/2021/08/22/%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>这几天在复习 qbxt 的知识，学到了线段树，就来总结一下。</p><h1 id="线段树">线段树</h1><p><img src="https://z3.ax1x.com/2021/08/17/f4sLWR.png" /></p><p>上面这张图显然是线段树，线段树就是一个处理区间的一个数据结构，将整个线段划分成一个树的结构，将长度不是1的段划分成两个子区间来求解，通过合并两个区间的信息来求解，这也是一个高效的数据结构。</p><p>总体时间复杂度为 <span class="math inline">\(O(\log n)\)</span></p><ul><li>适用范围：区间的最小值或最大值，区间的修改，区间求和</li></ul><h2 id="操作">操作</h2><p>在所有操作开始之前，可以观察到一个根节点为 <spanclass="math inline">\(p\)</span> 的左儿子为 <spanclass="math inline">\(p^2\)</span> ，右儿子为 <spanclass="math inline">\(p^2+1\)</span></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ls</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> x&lt;&lt;<span class="hljs-number">1</span>;&#125;   <span class="hljs-comment">// 左儿子 left sons</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> (x&lt;&lt;<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;&#125;   <span class="hljs-comment">// 右儿子 right sons</span><br></code></pre></div></td></tr></table></figure><h3 id="建树">建树</h3><p>我们可以想到像树上 DFS 一样，可以一直访问儿子节点，直到儿子节点长度为1，我们可以通过数据上的值去更改子节点的值，再有子节点来合并（更新）父节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">built</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>    <span class="hljs-comment">// 建树 [l,r] 为当前的区间，p 为当前的节点编号</span><br>lazy[p] = <span class="hljs-number">1</span>;<span class="hljs-comment">// lazy_tag 后面会讲到</span><br><span class="hljs-keyword">if</span>(l == r)&#123;<span class="hljs-comment">// 如果 长度为 1 </span><br>d[p] = a[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<span class="hljs-comment">// 递归求解</span><br><span class="hljs-built_in">built</span>(l,mid,<span class="hljs-built_in">ls</span>(p));<span class="hljs-built_in">built</span>(mid+<span class="hljs-number">1</span>,r,<span class="hljs-built_in">rs</span>(p));<br>d[p] = d[<span class="hljs-built_in">ls</span>(p)] + d[<span class="hljs-built_in">rs</span>(p)] ;  <span class="hljs-comment">// 由儿子更新父亲，合并</span><br>    <span class="hljs-comment">// 如果是求最大值，改成 d[p] = max(d[ls(p)],d[rs(p)]);最小值同样 </span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="区间查询">区间查询</h3><p>首先，我们可以想到还是像建树一样递归求解，如果这个区间在所要求的区间上了，直接返回，如果左儿子的子区间和原答案有交集，那么就递归到相应的节点上求解。那么思路就讲好了，代码怎么写呢？下面放上几张图就了解了</p><p>设所在区间为 <span class="math inline">\([l,r]\)</span> , 查询区间为<span class="math inline">\([s,t]\)</span> 。</p><figure><img src="https://z3.ax1x.com/2021/08/20/fj97CQ.jpg" alt="tree" /><figcaption aria-hidden="true">tree</figcaption></figure><p>那么根据这张图可以很显然的推出所在区间在查询区间的判断方式：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t)<br></code></pre></div></td></tr></table></figure><p>设中间位置为 <span class="math inline">\(mid =\dfrac{(l+r)}{2}\)</span> 。</p><p><img src="https://z3.ax1x.com/2021/08/20/fjiS1J.jpg" /></p><p>可以很<del>简单</del>的看出，进入左儿子的条件是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(mid &gt;= s)<br></code></pre></div></td></tr></table></figure><p>进入右儿子的条件是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(mid &lt; t)<br></code></pre></div></td></tr></table></figure><p>综上，我们可以得出查询代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// l,r 为当前的, s,t 为询问的</span><br><span class="hljs-keyword">if</span>(l&gt;=s &amp;&amp; r &lt;= tt)<br><span class="hljs-keyword">return</span> d[p];<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">pushdown</span>(p,l,r); <br>LL sum = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">if</span>(mid &gt;= s)<br>sum += <span class="hljs-built_in">query</span>(l,mid,s,t,<span class="hljs-built_in">ls</span>(p));    <span class="hljs-comment">// 如果是求最大值，就改成</span><br><span class="hljs-comment">// sum = max(quert(l,mid,s,t,ls(p)),sum);     最小值同样</span><br><span class="hljs-keyword">if</span>(tt &gt; mid)<br>sum += <span class="hljs-built_in">query</span>(mid+<span class="hljs-number">1</span>,r,s,tt,<span class="hljs-built_in">rs</span>(p));<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="单点修改">单点修改</h3><p>在讲区间修改之前，我先来讲一下最基础的单点修改。单点修改也是递归找需要更改的点，然后再返回合并父节点的值</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> f,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// [l,r] 当前 p 节点的范围，f 是修改的点的编号， c 是修改的值</span><br><span class="hljs-keyword">if</span>(l == r)&#123;<span class="hljs-comment">// 如果递归到所达到的点了</span><br>d[p] = c;<br><span class="hljs-comment">// 如果是加上 c ，改成</span><br><span class="hljs-comment">// d[p] += c;</span><br>        <span class="hljs-comment">// 减去同理</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> mid = l + (r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(mid &gt;= f)<span class="hljs-comment">// 如果所要修改的点在左儿子上，进入左儿子</span><br><span class="hljs-built_in">update</span>(l,mid,f,c,<span class="hljs-built_in">ls</span>(p));<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">update</span>(mid+<span class="hljs-number">1</span>,r,f,c,<span class="hljs-built_in">rs</span>(p));<br>d[p] = d[<span class="hljs-built_in">ls</span>(p)] + d[<span class="hljs-built_in">rs</span>(p)];<br>    <span class="hljs-comment">// 如果是求最大值，就改成</span><br>    <span class="hljs-comment">// d[p] = max(d[ls(p)] + d[rs(p)]);</span><br>    <span class="hljs-comment">// 最小值同理</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="区间修改">区间修改</h3><ul><li><p>懒标记</p><p>简单来说，就是通过<strong>延迟</strong>对节点信息的更改，从而减少可能不必要的操作次数。每次执行修改时，我们通过打标记的方法表明该节点对应的区间在某一次操作中被更改，但不更新该节点的子节点的信息。实质性的修改则在下一次访问带有标记的节点时才进行。</p><div class="hljs code-wrapper"><pre><code>                                                                                                                                                              ----- OI-Wiki</code></pre></div></li></ul><p>这段话<del>深刻的阐释了</del>懒标记的作用，如果不用懒标记时间复杂度将会达到<span class="math inline">\(\mathcal{O}(n \log n)\)</span>有点慢，这样一来时间复杂度为 <spanclass="math inline">\(\mathcal{O}(\log n)\)</span> 的。</p><p>听我这样一讲有点蒙先来看代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> tt,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// [l,r] 为当前的, [s,t] 为询问的</span><br><span class="hljs-keyword">if</span>(l &gt;= s &amp;&amp; r &lt;= tt)&#123;<br>t[p] += (r-l+<span class="hljs-number">1</span>)*c;lazy[p] += c  <span class="hljs-comment">//懒标记;</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(lazy[p] &amp;&amp; l!=r)&#123; <span class="hljs-comment">// 懒标记的更新</span><br>t[<span class="hljs-built_in">ls</span>(p)] += (mid-l+<span class="hljs-number">1</span>)*lazy[p];t[<span class="hljs-built_in">rs</span>(p)] += (r-mid) * lazy[p];<br>lazy[<span class="hljs-built_in">ls</span>(p)] += lazy[p];lazy[<span class="hljs-built_in">rs</span>(p)] += lazy[p];<br>lazy[p] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(mid &gt;= s)<br><span class="hljs-built_in">update</span>(l,mid,s,tt,c,<span class="hljs-built_in">ls</span>(p));<br><span class="hljs-keyword">if</span>(tt &gt; mid)<br><span class="hljs-built_in">update</span>(mid+<span class="hljs-number">1</span>,r,s,tt,c,<span class="hljs-built_in">rs</span>(p));<br>t[p] = t[<span class="hljs-built_in">ls</span>(p)] + t[<span class="hljs-built_in">rs</span>(p)];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>举个例子吧：</p><figure><img src="https://z3.ax1x.com/2021/08/22/hpaTg0.png" alt="step1" /><figcaption aria-hidden="true">step1</figcaption></figure><p>如果我想要更改 <span class="math inline">\([9,10]\)</span>的每个数加上 5，我们可以先直接在这个区间上改，并给它们打上标记。</p><figure><img src="https://z3.ax1x.com/2021/08/22/hpdV5d.png" alt="step2" /><figcaption aria-hidden="true">step2</figcaption></figure><p>虽然，子节点没有更新值，但当我们要查询这两个子节点的信息时，我们会利用标记修改这两个子节点的信息，使查询的结果依旧准确。</p><p>现在，来查询一下 <span class="math inline">\([9,9]\)</span>的值，当递归到 <span class="math inline">\([9,10]\)</span>时，因为懒标记不为 0 ，所以将该区间的子区间更新并清零。</p><figure><img src="https://z3.ax1x.com/2021/08/22/hpduxP.png" alt="step3" /><figcaption aria-hidden="true">step3</figcaption></figure><p>当然为了编写的简单性，修改懒标记可以写一个单独的函数<code>pushdown</code> 。</p><p>带乘法的查询也同理，只是新加一个乘法懒标记而已</p><h3 id="带懒标记的查询">带懒标记的查询</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> tt,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// l,r 为当前的, s,tt 为询问的</span><br><span class="hljs-keyword">if</span>(l&gt;=s &amp;&amp; r &lt;= tt)<br><span class="hljs-keyword">return</span> t[p];<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(lazy[p])&#123;<br>t[<span class="hljs-built_in">ls</span>(p)] += lazy[p] * (mid-l+<span class="hljs-number">1</span>);t[<span class="hljs-built_in">rs</span>(p)] += lazy[p] * (r-mid);<br>lazy[<span class="hljs-built_in">ls</span>(p)] += lazy[p];lazy[<span class="hljs-built_in">rs</span>(p)] += lazy[p];<br>lazy[p] = <span class="hljs-number">0</span>;<br>&#125;<br>LL sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(mid &gt;= s)<br>sum += <span class="hljs-built_in">query</span>(l,mid,s,tt,<span class="hljs-built_in">ls</span>(p));<br>    <span class="hljs-comment">// 如果是求最大值，就改成</span><br>    <span class="hljs-comment">// sum = max(quert(l,mid,s,t,ls(p)),sum);     最小值同理</span><br><span class="hljs-keyword">if</span>(tt &gt; mid)<br>sum += <span class="hljs-built_in">query</span>(mid+<span class="hljs-number">1</span>,r,s,tt,<span class="hljs-built_in">rs</span>(p));<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="习题">习题</h2><p>基本上有了这些操作就可以写以下几道题目：</p><ul><li><p><a href="https://www.luogu.com.cn/problem/P3372">洛谷 P3372【模板】线段树 1</a></p><p>这道题是个纯模板题</p></li><li><p><a href="https://www.luogu.com.cn/problem/P3373">洛谷 P3373【模板】线段树 2</a></p><p>这道题也差不多是个模板题，只是要注意：<strong>先乘后加</strong>懒标记</p></li><li><p><a href="https://vjudge.net/problem/HDU-1166">HDU-1166敌兵布阵</a></p><p>单点修改的模板</p></li><li><p><a href="https://vjudge.net/problem/HDU-1754">HDU-1754 I HateIt</a></p><p>单点修改，查询最大值的模板</p></li><li><p><a href="https://vjudge.net/problem/HDU-1394">HDU-1394 MinimumInversion Number</a></p><p>线段树解决逆序对问题</p></li><li><p><a href="https://vjudge.net/problem/POJ-3468">POJ-3468 A SimpleProblem with Integers</a></p><p>区间修改的模板题</p></li></ul><p>模板题/好题未完待续 <span class="math inline">\(\dots\dots\)</span></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA1160题解</title>
    <link href="/2021/08/22/UVA1160%E9%A2%98%E8%A7%A3/"/>
    <url>/2021/08/22/UVA1160%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="前置知识">前置知识</h2><ul><li>并查集</li></ul><p>简单的查找（带路经压缩）:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x == fa[x] ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>    <span class="hljs-comment">// fa[i] 为并查集的数组</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>查找（这里可以数据小完全不需要用启发式合并）：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">int</span> f = <span class="hljs-built_in">find</span>(x),t = <span class="hljs-built_in">find</span>(y);<br>    fa[f] = t;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>查阅资料可知，只用路径压缩，不用启发式合并的平均时间复杂度为 <spanclass="math inline">\(\mathcal{O}(\alpha (n))\)</span>，最坏时间复杂度为 <span class="math inline">\(\mathcal{O}(m \logn)\)</span> 。</p><h2 id="思路">思路</h2><p>首先可以将每个元素看成点，化合物看成边，因为如果有超过 3个物品互相形成化合物就会爆炸，所以会爆炸的条件可以看成两个是在同一祖先（在同一集合）中，（如果这两个点有一个祖先的话，合并就会有3 个物品在一起的）。</p><p>每一次都将不在一个集合中两个数合并。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> fa[<span class="hljs-number">100010</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x == fa[x] ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> x,y;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x) == <span class="hljs-number">1</span>)&#123;    \\ 注意输入<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100010</span>;i++)fa[i] = i;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x != <span class="hljs-number">-1</span>)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;y);<br><span class="hljs-keyword">int</span> f = <span class="hljs-built_in">find</span>(x),t = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(f == t)ans ++;<br><span class="hljs-keyword">else</span><br>fa[f] = t;    <span class="hljs-comment">// 如果不会爆炸，就合并</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>UVA</tag>
      
      <tag>并查集</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python实现爬取UVA题库的PDF</title>
    <link href="/2021/08/09/Python%E5%AE%9E%E7%8E%B0%E7%88%AC%E5%8F%96UVA%E9%A2%98%E5%BA%93%E7%9A%84PDF/"/>
    <url>/2021/08/09/Python%E5%AE%9E%E7%8E%B0%E7%88%AC%E5%8F%96UVA%E9%A2%98%E5%BA%93%E7%9A%84PDF/</url>
    
    <content type="html"><![CDATA[<p>我在一次看洛谷日报时了解到了有一个软件可以下载 UVA 的 PDF ，我试了一下连接不上，可能是软件的作者太久没有更新了无法下载了，我便自己写了一个Python ,可能有些不好的地方。</p><h3 id="代码">代码</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> urllib3<br><span class="hljs-keyword">import</span> time<br><br>url = <span class="hljs-string">&#x27;https://uva.onlinejudge.org/external/1/p&#x27;</span><br><br>urllib3.disable_warnings()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download</span>(<span class="hljs-params">name,url</span>):</span><br>    response = requests.get(url,verify=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 就是这个地方不能用异步，有没有大佬知道为什么</span><br>    <span class="hljs-built_in">print</span>(response)<br>    f = <span class="hljs-built_in">open</span>(name,<span class="hljs-string">&#x27;wb&#x27;</span>)<br>    f.write(response.content)<br>    f.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span> :<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----------------------------------&quot;</span>)<br>        i = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你所需要的 UVA 题号 ： &quot;</span>))<br>        time.sleep(<span class="hljs-number">3</span>)<br>        download(<span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;.pdf&#x27;</span>,url + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;.pdf&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>注 ： 还会根据我的需要不定时更新</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA11426 GCD - Extreme (II)</title>
    <link href="/2021/07/28/UVA11426-GCD-Extreme-II/"/>
    <url>/2021/07/28/UVA11426-GCD-Extreme-II/</url>
    
    <content type="html"><![CDATA[<h1 id="uva11426-gcd---extreme-ii">UVA11426 GCD - Extreme (II)</h1><p>这几天我看了 LRJ的书看到了这一题，就把这道题写了，正好这道题挺不错的。</p><h2 id="题目">题目</h2><p><ahref="https://uva.onlinejudge.org/external/114/p11424.pdf">题目PDF</a></p><h2 id="知识">知识</h2><h3 id="欧拉函数">欧拉函数</h3><ul><li>定义： <span class="math inline">\(\varphi(n)\)</span> 为小于等于<span class="math inline">\(n\)</span> 与 <spanclass="math inline">\(n\)</span> 互质的数的个数</li></ul><p>它有一些有趣的性质：</p><ul><li><span class="math inline">\(\varphi(n)\)</span> 是积性函数 ： 如果有<span class="math inline">\(\gcd(i,j) = 1\)</span> 那么就有 <spanclass="math inline">\(\varphi(i \times j) = \varphi(i) \times\varphi(j)\)</span></li></ul><h3 id="如何求欧拉函数">如何求欧拉函数：</h3><p>用一个类似于筛法求素数的方法，时间复杂度相似于埃氏筛法 <spanclass="math inline">\(\mathcal{O}(n\log \log n)\)</span></p><p><strong>模板代码</strong>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> phi[maxn];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">table</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i ++)<br>        phi[i] = <span class="hljs-number">0</span>;<br>    phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i ++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt;= n;j ++)&#123;<br>    <span class="hljs-keyword">if</span>(!phi[j])phi[j] = j;<br>    phi[j] = phi[j] / i * (i<span class="hljs-number">-1</span>);<br>    &#125;<br>   <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="思路">思路</h2><p>首先，我们能想到暴力，每一次将每一个的 <spanclass="math inline">\(\gcd\)</span> 求出 ，最差时间复杂度为 <spanclass="math inline">\(\mathcal{O}(n^2\log n )\)</span>，太慢，在这个数据目前无能为力，所以想办法优化。</p><p>设 <span class="math display">\[\large f(n) =\sum\limits_{i=1}^{n-1}\gcd(i,n)\]</span> ，</p><p>所以答案为 <span class="math display">\[\large S(n) =\sum\limits_{i=1}^{n} f(i)\]</span>。</p><p><del>易证</del> ，<span class="math inline">\(\gcd(i,n)\)</span>的值都是 n 的约数，我们好好看看这个柿子有什么优化的地方</p><p>设 <span class="math inline">\(\dfrac{x}{i}\)</span> ，所以 <spanclass="math inline">\(\gcd(\dfrac{x}{i},\dfrac{n}{i}) = 1\)</span></p><p><span class="math inline">\(\therefore\)</span> <spanclass="math inline">\(\dfrac{x}{i}\)</span> 与 <spanclass="math inline">\(\dfrac{n}{i}\)</span> 互质</p><p>所以小于等于 <span class="math inline">\(\dfrac{n}{i}\)</span>的互质的 <span class="math inline">\(\dfrac{x}{i}\)</span> 一共有 <spanclass="math inline">\(\varphi(\dfrac{n}{i})\)</span> 个</p><p>又 <span class="math inline">\(\because\)</span> <spanclass="math inline">\(\gcd(i,n)\)</span> <spanclass="math inline">\(\leqslant n\)</span></p><p>$$ <span class="math inline">\(\large f(n) = \sum\limits_{i\subset A}i \times \varphi(\dfrac{n}{i})\)</span> <span class="math inline">\(( A= n\)</span> 的约数 <span class="math inline">\()\)</span></p><p>上面的柿子就是我们所需要的，时间复杂度与求欧拉筛法同阶。</p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">4000000</span>;<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> phi[maxn],s[maxn],f[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">phi_c</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=maxn;i++)phi[i] = <span class="hljs-number">0</span>;<br>phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=maxn;i++)&#123;<br><span class="hljs-keyword">if</span>(!phi[i])<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=maxn;j+=i)&#123;<br><span class="hljs-keyword">if</span>(!phi[j])<br>phi[j] = j;<br>phi[j] = phi[j] / i * (i<span class="hljs-number">-1</span>);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">phi_c</span>();<br><span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=maxn;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i*<span class="hljs-number">2</span>;j&lt;=maxn;j+=i)<br>f[j] += i*phi[j/i];<br><br>s[<span class="hljs-number">2</span>] = f[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">3</span>;j&lt;=maxn;j++)<br>s[j] = s[j<span class="hljs-number">-1</span>] + f[j];<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n) &amp;&amp; n)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,s[n]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>筛法</tag>
      
      <tag>题解</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合数</title>
    <link href="/2021/07/05/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    <url>/2021/07/05/%E7%BB%84%E5%90%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>这几天的竞赛期末考试中遇到了组合数的题目，就是 <ahref="https://www.luogu.com.cn/problem/P2822">NOIP2016 组合数问题</a>原题，正好现在数学学到了一点点排列组合，就来整理一下吧。</p><h2 id="组合数">组合数</h2><p>就是从 <span class="math inline">\(n\)</span> 个不同元素中，抽取<span class="math inline">\(m\)</span> 个元素的方案数。</p><p>组合数公式为：</p><p><span class="math display">\[\dbinom{n}{m}= \dfrac{n!}{m! \times(n-m)!}\]</span></p><p>通过杨辉三角可得到递推公式：</p><p><span class="math inline">\(\dbinom{i}{j} = \dbinom{i-1}{j-1} +\dbinom{i-1}{j}\)</span></p><p>还有一个递推公式（可证明）：</p><p><span class="math display">\[\dbinom{i}{j} = \dfrac{n-k+1}{k} \times\dbinom{i}{j-1}\]</span></p><p>但是这个可能会乘法溢出</p><details><summary>证明</summary><img src="http://latex.codecogs.com/gif.latex?\dbinom{n}{k} = \dfrac{n!}{k!(n-k)!} = \dfrac{n\cdot(n-1)\cdot(n-2)\dots\cdot1}{k\cdot(k-1)\dots\cdot1\cdot(n-k)\cdot(n-k-1)\dots\cdot1}" /><br><br><img src="http://latex.codecogs.com/gif.latex?\dbinom{n}{k-1} \cdot \dfrac{n-k+1}{k} = \dfrac{n\cdot(n-1)\cdot(n-2)\dots\cdot1\cdot(n - k + 1)}{k\cdot(k-1)\dots\cdot1\cdot(n-k+1)\cdot(n-k-1)\dots\cdot1}" /><br><br><img src="http://latex.codecogs.com/gif.latex? = \dbinom{n}{k}" /><br><br><img src="http://latex.codecogs.com/gif.latex?\therefore" />证明完毕</details><h2 id="题目思路">题目思路</h2><ul><li><p>暴力</p><p>暴力，暴力，暴力！</p></li><li><p>预处理</p><p>用第一个递推公式先递推出来所有的数，然后对于每一次查询进行判断是否 %k == 0，时间复杂度为 <spanclass="math inline">\(\mathcal{O}(q+tn^2)\)</span>，还是有点慢</p></li><li><p>预处理优化</p><p>我们可以想到每一判断都 % k 有点慢所以可以在预处理时 % k，判断是否等于0 ，开过 <span class="math inline">\(O2\)</span> 95pts，还需要优化。</p></li><li><p>前缀和+预处理</p><p>我们可以二维前缀和等于 0 的个数，然后每一次查询即可，时间复杂度变成了<span class="math inline">\(\mathcal{O}(q+t)\)</span> ,可以过了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> p = <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">int</span> c[<span class="hljs-number">2010</span>][<span class="hljs-number">2010</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> f[<span class="hljs-number">2010</span>][<span class="hljs-number">2010</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> n,m,k,t;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">complet</span><span class="hljs-params">()</span></span>&#123;<br>c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>c[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">2000</span>;i++)&#123;<br>c[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>c[i][i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>c[i][j] = (c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + c[i<span class="hljs-number">-1</span>][j]) % k;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">2000</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>        f[i][j] = f[i<span class="hljs-number">-1</span>][j] + f[i][j<span class="hljs-number">-1</span>] - f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];\\ 前缀和<br>        <span class="hljs-keyword">if</span>(c[i][j] == <span class="hljs-number">0</span>)f[i][j] ++;<br>        &#125;<br>        f[i][i+<span class="hljs-number">1</span>] = f[i][i];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>cin&gt;&gt;t&gt;&gt;k;<br><span class="hljs-built_in">complet</span>();<br><span class="hljs-keyword">while</span>(t--)&#123;<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">if</span>(m &gt; n)<br>m = n;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[n][m]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>组合数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCA问题</title>
    <link href="/2021/06/23/LCA%E9%97%AE%E9%A2%98/"/>
    <url>/2021/06/23/LCA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="lca">LCA</h1><p>LCA 的问题是很经典的，我这一次就来讲解一下 LCA的求法，就先从一道模板题入手吧</p><h2 id="题目">题目</h2><p><a href="https://www.luogu.com.cn/problem/P3379">P3379【模板】最近公共祖先（LCA）</a></p><h3 id="输入格式">输入格式</h3><p>第一行包含三个正整数 <span class="math inline">\(N,M,S\)</span>分别表示树的结点个数、询问的个数和树根结点的序号。</p><p>接下来 <span class="math inline">\(N-1\)</span> 行每行包含两个正整数<span class="math inline">\(x, y\)</span> 表示 <spanclass="math inline">\(x\)</span> 结点和 <spanclass="math inline">\(y\)</span>结点之间有一条直接连接的边（数据保证可以构成树）。</p><p>接下来 <span class="math inline">\(M\)</span> 行每行包含两个正整数<span class="math inline">\(a, b\)</span> 表示询问 <spanclass="math inline">\(a\)</span> 结点和 <spanclass="math inline">\(b\)</span> 结点的最近公共祖先。</p><h3 id="输出格式">输出格式</h3><p>输出包含 <span class="math inline">\(M\)</span>行，每行包含一个正整数，依次为每一个询问的结果。</p><h3 id="说明提示">说明/提示</h3><p>对于 <span class="math inline">\(30\%\)</span> 的数据，<spanclass="math inline">\(N\leq 10，N \leq 10\)</span>。</p><p>对于 <span class="math inline">\(70\%\)</span> 的数据，<spanclass="math inline">\(N\leq 10000，N \leq 10000\)</span>。</p><p>对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(N\leq 500000 ， N \leq 500000\)</span></p><h2 id="方法">方法</h2><h3 id="lca-的一些性质">LCA 的一些性质</h3><ul><li>两点的距离 ： $ d(u,v) = h(u) + h(v) + h((u,v) )$ ，<spanclass="math inline">\(h\)</span> 代表某一点的深度</li><li>两点的最近公共祖先必定处在树上两点间的最短路上；</li></ul><h3 id="朴素算法">朴素算法</h3><p>首先，我们想到最暴力的方法，先把整个树 DFS一下，顺便将每个点的深度记录下来，将要查找的两个点中每次找深度最大的点，然后向上跳一格，最后两个点一定会相遇，相遇的点就一定是他们的LCA 。</p><p>下面是 DFS 的代码</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa)</span></span>&#123;     <span class="hljs-comment">// fa 为父亲节点，u 为当前节点， dep 为节点深度</span><br>    f[u] = fa;<br>    dep[u] = dep[fa] + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 因为是 DFS ，每个节点是从它的父亲来的，父亲与儿子的深度相差 1 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];i;i = nex[i])&#123;        <span class="hljs-comment">// 链式前向星</span><br>        <span class="hljs-keyword">int</span> v = to[i]; <br>        <span class="hljs-keyword">if</span>(v != fa)<br>            <span class="hljs-built_in">dfs</span>(v,u);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后是 LCA 的核心代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(x != y)&#123;<br>        <span class="hljs-keyword">if</span>(dep[x] &gt;= dep[y])    x = f[x];<br>        <span class="hljs-keyword">else</span> y = f[y];<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br></code></pre></div></td></tr></table></figure><p>很简单，就不详细讲了， 预处理时间复杂度是 <spanclass="math inline">\(\mathcal{O}(n)\)</span> ， 单次查询时间复杂度为<span class="math inline">\(\Theta(n \log n)\)</span> （随机树上)，时间有点慢，遇到大数据就不行了，我们需要优化</p><h3 id="倍增-lca">倍增 LCA</h3><p>这里先来了解一下<strong>倍增</strong>（<ahref="https://blog.csdn.net/jarjingx/article/details/8180560">更容易理解</a>），顾名思义，一倍一倍的增加，就比如一步一步跳7 格，但是我们可以先跳 <span class="math inline">\(2^2= 4\)</span>次，再跳 <span class="math inline">\(2\)</span> 次，最后跳 <spanclass="math inline">\(1\)</span> 次，原本需要跳 7 次，通过倍增只需要跳 3次。</p><p>这里可以倍增首先基于一个推论 ：</p><ul><li><p>任意整数可以表示成若干个 2 的次幂项的和</p><p><span class="math inline">\(eg. 7 = 2^2 + 2^1 + 2^0\)</span></p><p><span class="math inline">\(10 = 2^3 + 2^1\)</span></p></li></ul><p>下面来讲一下倍增 LCA :</p><p>显然可以将一步一步跳变成倍增，在 DFS 时可以通过 <spanclass="math inline">\(2^i = 2^{i-1}+2^{i-1}\)</span> 预处理 <spanclass="math inline">\(fa_i\)</span> 的位置。</p><p>在查询时可以从小到大倍增（<spanclass="math inline">\(2^0,2^1,2^2\dots\)</span>）来将 <spanclass="math inline">\(u,v\)</span> 跳到同一深度，在同时跳的时候从大到小倍增（<span class="math inline">\(2^i,2^{i-1}\dots2^1,2^0\)</span>），如果两个父亲不一样，就跳，那么最后的 LCA 是 <spanclass="math inline">\(fa_0\)</span></p><p>倍增 LCA 预处理时间复杂度为 <span class="math inline">\(\mathcal{O}(n\log n)\)</span> ，单次查询时间为 <spanclass="math inline">\(\mathcal{O}(\log n)\)</span> 。</p><p>这个时间复杂度大部分题目都是可以接受的。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span></span>&#123;<br>    dep[u] = dep[v] + <span class="hljs-number">1</span>;<br>    fa[u][<span class="hljs-number">0</span>] = v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">19</span>;i++)<br>        fa[u][i] = fa[fa[u][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(G[u][i] == v)    <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(G[u][i],u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(dep[x] &gt; dep[y])        <span class="hljs-built_in">swap</span>(x,y);<br>    <span class="hljs-keyword">int</span> tmp = dep[y] - dep[x];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;tmp;i++,tmp &gt;&gt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span>(tmp &amp; <span class="hljs-number">1</span>)<br>            y = fa[y][i];<br>    <span class="hljs-keyword">if</span>(x == y)    <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">19</span>;i&gt;=<span class="hljs-number">0</span> &amp;&amp; x != y;i--)<br>        <span class="hljs-keyword">if</span>(fa[x][i] != fa[y][i])&#123;x = fa[x][i];y = fa[y][i];&#125;<br>    <span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LCA</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1A Theatre Square</title>
    <link href="/2021/05/16/CF1A-Theatre-Square/"/>
    <url>/2021/05/16/CF1A-Theatre-Square/</url>
    
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><h2 id="题目描述">题目描述</h2><p>用 <span class="math inline">\(a \times a\)</span> 的石板覆盖 <spanclass="math inline">\(n \times m\)</span>的长方形广场，允许石板覆盖的区域超出广场，不允许打破石板，石板的两侧应平行于广场两侧，要求覆盖完广场所需的石板数量最少是多少。</p><h1 id="输入格式">输入格式</h1><p>输入有三个数字 <span class="math inline">\(n,m,a\)</span> (<spanclass="math inline">\(1≤n,m,a≤10^9\)</span>)</p><h1 id="思路">思路</h1><p>首先，我们看到是广场是长方形的，而石板是正方形的，<del>很容易就想到</del>可能会出现一中特殊情况：（广场的面积不足以铺一个石板），还会想到将长和宽一起除以石板边长，就是这个边所可以容纳多少个石板边长，最后再将所得的个数相乘，就是我们的答案了。<img src="https://z3.ax1x.com/2021/05/16/gcWxnP.png"alt="gcWxnP.png" /></p><p><span class="math inline">\(AC\)</span> 代码： <figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,m,a;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;a;<br>cout&lt;&lt;(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)(<span class="hljs-built_in">ceil</span>(n/(<span class="hljs-keyword">double</span>)a)*<span class="hljs-built_in">ceil</span>(m/(<span class="hljs-keyword">double</span>)a))&lt;&lt;endl;<span class="hljs-comment">//注意一定要long long 不然就会强制转换为科学计数法</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><br></code></pre></div></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>简单题</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P3383 【模板】线性筛素数</title>
    <link href="/2021/04/07/P3383-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0/"/>
    <url>/2021/04/07/P3383-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><p><a href="https://www.luogu.com.cn/problem/P3383">P3383【模板】线性筛素数</a> ## 题目描述</p><p>如题，给定一个范围<span class="math inline">\(n\)</span>，有<spanclass="math inline">\(q\)</span>个询问，每次输出第<spanclass="math inline">\(k\)</span>小的素数。</p><h2 id="输入格式">输入格式</h2><p>第一行包含两个正整数 <spanclass="math inline">\(n,q\)</span>，分别表示查询的范围和查询的个数。</p><p>接下来<span class="math inline">\(q\)</span>行每行一个正整数<spanclass="math inline">\(k\)</span>，表示查询第<spanclass="math inline">\(k\)</span>小的素数。</p><h2 id="输出格式">输出格式</h2><p>输出<spanclass="math inline">\(q\)</span>行，每行一个正整数表示答案。</p><h2 id="数据范围">数据范围</h2><p>对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(n =10^8,1≤q≤10^6\)</span>，保证查询的素数不大于<spanclass="math inline">\(n\)</span>。</p><h1 id="知识题解">知识/题解</h1><p>这题是一道筛法模版题，第一个先想到的应该是暴力枚举，但是暴力枚举时间复杂度显然太高，然后经过一番搜寻，找到了埃式筛。</p><h3 id="埃式筛">埃式筛</h3><p>这个筛法的时间复杂度为<span class="math inline">\(O(n\log\logn)\)</span>,算的上是比较优秀了。</p><blockquote><p>如果<span class="math inline">\(x\)</span>是合数，那么<spanclass="math inline">\(x\)</span>的倍数也一定是合数。</p></blockquote><p>这个规则很容易就知道了是对的，是吧，这样我们要求100以内的数就只需将1到10以内的倍数枚举并标记，没有标记的数就是质数，这个筛法就是这个思想。<br />埃式筛的代码如下： <figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Eratosthenes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) is_prime[i] = <span class="hljs-number">1</span>;<br>  is_prime[<span class="hljs-number">0</span>] = is_prime[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (is_prime[i]) &#123;<br>      prime[p++] = i;  <span class="hljs-comment">// prime[p]是i,后置自增运算代表当前素数数量</span><br>      <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)i * i &lt;= n)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * i; j &lt;= n; j += i)<br>          <span class="hljs-comment">// 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i</span><br>          <span class="hljs-comment">// 的倍数开始，提高了运行速度</span><br>          is_prime[j] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 是i的倍数的均不是素数</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br><br></code></pre></div></td></tr></table></figure></p><p>但是这个还是有点慢，这个数据可能会过不了，所以我们又找到了另一个更快的算法：欧拉筛（线性筛）。</p><h3 id="线性筛">线性筛</h3><p>埃氏筛法仍有优化空间，它会将一个合数重复多次标记，所以线性筛就是来解决这个事情的。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; MAXN; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>      prime[cnt++] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-number">1ll</span> * i * prime[j] &gt;= MAXN) <span class="hljs-keyword">break</span>;<br>      vis[i * prime[j]] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 换言之，i 之前被 pri[j] 筛过了</span><br>        <span class="hljs-comment">// 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定也是</span><br>        <span class="hljs-comment">// pri[j] 的倍数 它们都被筛过了，就不需要再筛了，所以这里直接 break</span><br>        <span class="hljs-comment">// 掉就好了</span><br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h1 id="本题ac代码">本题AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">bool</span> visited[<span class="hljs-number">100000010</span>];<br><span class="hljs-keyword">int</span> prime[<span class="hljs-number">6000010</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shai</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(!visited[i])prime[cnt++] = i;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt;j++)&#123;<br><span class="hljs-keyword">if</span>(i * prime[j] &gt; n)<br><span class="hljs-keyword">break</span>;<br>visited[i * prime[j]] = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,m,x;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">shai</span>(n);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,prime[x<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-built_in">getchar</span>();<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>筛法</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P1029 [NOIP2001 普及组] 最大公约数和最小公倍数</title>
    <link href="/2021/04/02/P1029-NOIP2001-%E6%99%AE%E5%8F%8A%E7%BB%84-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
    <url>/2021/04/02/P1029-NOIP2001-%E6%99%AE%E5%8F%8A%E7%BB%84-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><h2 id="题目描述">题目描述</h2><p>输入两个正整数<span class="math inline">\(x_0,y_0\)</span>，求出满足下列条件的<span class="math inline">\(P,Q\)</span>的个数:<br />1. <span class="math inline">\(P,Q\)</span> 是正整数。 2. 要求 <spanclass="math inline">\(P, Q\)</span> 以 <spanclass="math inline">\(x_0\)</span>为最大公约数，以<spanclass="math inline">\(y_0\)</span>为最小公倍数。</p><p>试求：满足条件的所有可能的<span class="math inline">\(P,Q\)</span>的个数。 ## 输入格式 一行两个正整数<spanclass="math inline">\(x_0, y_0\)</span>。 ## 输出格式一行一个数，表示求出满足条件的<span class="math inline">\(P,Q\)</span>个数。</p><h1 id="知识讲解">知识讲解</h1><p>这一题是关于最大公约数（gcd）和最小公倍数（lcm）的，首先要算最大公约数，最好的算法是<ahref="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&amp;fromid=4625352">欧几里得算法</a>（辗转相除法）然而本人是个蒟蒻，所以还是要来证明一下的：### 最大公约数 设 <span class="math inline">\(a=bk+c\)</span> 则有 <spanclass="math inline">\(c= a\bmod b\)</span> ,设有一个数 <spanclass="math inline">\(d \mid a~,d \midb\)</span>（这个符号表示前者是后者的因数，能整除）, 则存在 <spanclass="math inline">\(c=a-bk\)</span> ， <spanclass="math inline">\(\dfrac{c}{d} = \dfrac{a-b}{d}k\)</span>。<br />显而易见，<span class="math inline">\(\dfrac{c}{d}\)</span>为整数，所以对于 <span class="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 的最大公约数为 <spanclass="math inline">\(a\bmod b\)</span> 的最大公约数（因为c为<spanclass="math inline">\(c= a\bmod b\)</span>），<br />所以 $ (a,b) = (a,ab)$,而这，就是欧几里得算法的核心内容。(终于结束了)下面给出欧几里得算法的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><br>下面我们来讲最小公倍数的算法，最小公倍数可以通过最大公约数来求.</p><h3 id="最小公倍数">最小公倍数</h3><p>首先我们介绍这样一个定理——算术基本定理：</p><blockquote><p>每一个正整数都可以表示成若干整数的乘积，这种分解方式在忽略排列次序的条件下是唯一的。</p></blockquote><p>这个有一个通式 <span class="math inline">\(\largex=p_1^{k_1}p_2^{k_2}p_3^{k_3}\dots b p_s^{k_s}\)</span></p><p>设 <span class="math display">\[\largea=p_1^{k_{a_1}}p_2^{k_{a_2}}p_3^{k_{a_3}} \dots p_s^{k_{a_s}} ,\largeb=p_1^{k_{b_1}}p_2^{k_{b_2}}p_3^{k_{b_3}}\dotsbp_s^{k_{b_s}}\]</span></p><p>可以得到，最大公约数为：<br /><span class="math display">\[\largep_1^{\min(k_{a_1},k_{b_1})}p_2^{\min(k_{a_2},k_{b_2})}\dotsbp_s^{\min(k_{a_s},k_{b_s})}\]</span></p><p>最小公倍数为：<br /><span class="math display">\[\largep_1^{\max(k_{a_1},k_{b_1})}p_2^{\max(k_{a_2},k_{b_2})}\dotsbp_s^{\max(k_{a_s},k_{b_s})}\]</span></p><p>将以上两个式子相乘，可以得到: &gt; $ (a,b)(a,b)=ab$</p><p>将上面的式子进行移项，就终于得到了这个重要的计算方法（呼，累死我了）：</p><blockquote><p><span class="math inline">\(\large \operatorname{lcm}(a,b) = a\timesb \div \gcd(a,b)\)</span></p></blockquote><h2 id="题解思路">题解思路</h2><p>那么，这道题基本的知识都讲完了，总结一下思路： 首先我们可以枚举<spanclass="math inline">\(P\)</span>，那么<spanclass="math inline">\(Q\)</span>可通过已经给的最小公倍数和最大公约数来求，然后再算出本身这两个数的最小公倍数和最大公约数，判断它们是否相等。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">LL <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123; <span class="hljs-comment">//最大公约数的算法</span><br><span class="hljs-keyword">return</span>  b==<span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>LL n,m,ans = <span class="hljs-number">0</span>;<br>cin&gt;&gt;n&gt;&gt;m;<br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">sqrt</span>(m*n);i++)&#123;  <span class="hljs-comment">//枚举到sqrt个即可</span><br><span class="hljs-keyword">if</span>(n==m)&#123;<br>ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">int</span> j = m*n/i;  <br>LL x = <span class="hljs-number">0</span>,y = <span class="hljs-number">0</span>;<br>LL cnt = <span class="hljs-built_in">gcd</span>(i,j);<br><span class="hljs-keyword">if</span>(cnt == n &amp;&amp; i*j/cnt == m)   <span class="hljs-comment">//i*j/cnt 是算最大公约数的算法</span><br>ans += <span class="hljs-number">2</span>;<br>&#125;<br><br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>LCM</tag>
      
      <tag>GCD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树(模板)</title>
    <link href="/2021/02/20/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%A8%A1%E6%9D%BF/"/>
    <url>/2021/02/20/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><p>这是个模板题 <strong>链接</strong>:<ahref="https://www.luogu.com.cn/problem/P3366">P3366【模板】最小生成树</a> ## 题目描述如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 orz。</p><h2 id="输入格式">输入格式</h2><p>第一行包含两个整数 $ N,M $ ，表示该图共有 $ N $ 个结点和 $ M $条无向边。 接下来 $ M $ 行每行包含三个整数 $ X_i,Y_i,Z_i $,示有一条长度为 $ Z_i $ 的无向边连接结点 $ X_i,Y_i $。</p><h2 id="输出格式">输出格式</h2><p>如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出orz。</p><h2 id="数据规模">数据规模</h2><p>对于 20% 的数据，$ N≤5，M≤20 $ 。</p><p>对于 40% 的数据，$ N≤50，M≤2500 $ 。</p><p>对于 70% 的数据，$ N≤500，M≤10 $ 。</p><p>对于 100%100% 的数据：$ 50001≤N≤5000， 1≤M≤2×10^5 $ 。</p><h1 id="题解">题解</h1><p>Kruskal 算法的主要思路： 1. 先以边的权值来给边排序，从小到大</p><figure><img src="https://z3.ax1x.com/2021/09/08/hb8YcQ.png" alt="dis0" /><figcaption aria-hidden="true">dis0</figcaption></figure><ol start="2" type="1"><li>然后开始由小到大遍历边，也就是一步一步的点的扩展</li></ol><figure><img src="https://z3.ax1x.com/2021/09/08/hb8J1g.png" alt="dis1" /><figcaption aria-hidden="true">dis1</figcaption></figure><ol start="3" type="1"><li>然后判断这个点的是否在已拓展的点内，如果不在就将答案加上它的边权，并且加入并查集</li></ol><figure><img src="https://z3.ax1x.com/2021/09/08/hb8G9S.png" alt="dis2" /><figcaption aria-hidden="true">dis2</figcaption></figure><figure><img src="https://z3.ax1x.com/2021/09/08/hb81tf.png" alt="dis3" /><figcaption aria-hidden="true">dis3</figcaption></figure><figure><img src="https://z3.ax1x.com/2021/09/08/hb83h8.png" alt="dis4" /><figcaption aria-hidden="true">dis4</figcaption></figure><p><strong>注意一下，这个是用邻接表edge写的（u，v为边的两个点，为边权），没有用领接矩阵</strong></p><p>基本上这个模板就这样了，代码如下：</p><p>​</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span> <br><span class="hljs-keyword">int</span> u,v,w;    <span class="hljs-comment">//定义一个边的结构体，u、v为边的两个定点，w为边的边权</span><br>&#125;;<br><br><br><br>edge e[<span class="hljs-number">200005</span>];<br><span class="hljs-keyword">int</span> father[<span class="hljs-number">5005</span>];      <span class="hljs-comment">//并查集</span><br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> edge&amp; a,<span class="hljs-keyword">const</span> edge&amp; b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a.w &lt; b.w;        <span class="hljs-comment">//sort（）的判断，以边权的由大到小的顺序来排序 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">found</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;          <span class="hljs-comment">//并查集的寻找父亲</span><br><span class="hljs-keyword">return</span> father[x] == x ? x : father[x] = <span class="hljs-built_in">found</span>(father[x]);        <span class="hljs-comment">//压行，并且压缩路径，这样可以将之后的查找时间变为常数级</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,m;<br><br>cin&gt;&gt;n&gt;&gt;m;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);<br>&#125;<br><br><span class="hljs-built_in">sort</span>(e,e+m,cmp);    <span class="hljs-comment">//kruskal 算法的重要部分：按照边权的大小来排序</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)father[j] = j;  <span class="hljs-comment">//初始化，每一个点都是一个自己的父亲</span><br><br><span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;=m;j++)<br>&#123;<br><span class="hljs-keyword">if</span>(k == n - <span class="hljs-number">1</span>)<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">int</span> v = e[j].v,u = e[j].u;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">found</span>(v) != <span class="hljs-built_in">found</span>(u))        <span class="hljs-comment">//如果没有这个边所在的点没有加入，就执行下面</span><br>&#123;<br>k++;   <span class="hljs-comment">//注意一点：这一句话一定要在这里写，我已经掉过坑里了</span><br>ans += e[j].w;    <span class="hljs-comment">//加入答案：最小生成树的总长</span><br><br><span class="hljs-keyword">int</span> f = <span class="hljs-built_in">found</span>(v),t = <span class="hljs-built_in">found</span>(u);<br>father[t] = f;          <span class="hljs-comment">//使这个的边的这个点加入路径</span><br>&#125;<br>&#125;<br><br><br><br><br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">if</span>(father[i] == i)<br>                cnt++;<br><br><br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">1</span>)<br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">else</span><br>cout&lt;&lt;<span class="hljs-string">&quot;orz&quot;</span>&lt;&lt;endl;        <span class="hljs-comment">//如果有边不联通，就输出“orz”</span><br><span class="hljs-built_in">getchar</span>();<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kruskal</tag>
      
      <tag>最小生成树</tag>
      
      <tag>题解</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过河卒</title>
    <link href="/2021/02/18/%E8%BF%87%E6%B2%B3%E5%8D%92/"/>
    <url>/2021/02/18/%E8%BF%87%E6%B2%B3%E5%8D%92/</url>
    
    <content type="html"><![CDATA[<h1 id="过河卒">过河卒</h1><p><strong>本题链接</strong>：<ahref="https://www.luogu.com.cn/problem/P1002">p1002 过河卒</a> ##题目描述</p><p>棋盘上 $ A $ 点有一个过河卒，需要走到目标$ B$点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $ C $点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。</p><p>棋盘用坐标表示，$ A $ 点 $ (0,0) $ 、$ B $ 点 $ (n,m) $，同样马的位置坐标是需要给出的。</p><p>现在要求你计算出卒从 $ A $ 点能够到达 $ B $点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。<br />## 输入格式</p><p>一行四个正整数，分别表示 $ B $ 点坐标和马的坐标。 ## 输出格式一个整数，表示所有的路径条数。</p><h2 id="说明提示">说明/提示</h2><p>对于100%的数据, $ 1≤n,m≤20 $ ，$ 0≤ $ 马的坐标 $ ≤20 $。</p><h1 id="求解">求解</h1><p>我看到这题时，我就想到用递推来做这题</p><h4 id="根据题意并根据样例第一步可以写出下列-简单的-表格">1.根据题意并根据样例，第一步可以写出下列 <del>（简单的）</del> 表格：</h4><table><colgroup><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /></colgroup><thead><tr><th style="text-align: right;"></th><th style="text-align: right;">[0]</th><th style="text-align: right;">[1]</th><th style="text-align: right;">[2]</th><th style="text-align: right;">[3]</th><th style="text-align: right;">[4]</th><th style="text-align: right;">[5]</th><th style="text-align: right;">[6]</th></tr></thead><tbody><tr><td style="text-align: right;">[0]</td><td style="text-align: right;">0</td><td style="text-align: right;">1</td><td style="text-align: right;">1</td><td style="text-align: right;">1</td><td style="text-align: right;">1</td><td style="text-align: right;">1</td><td style="text-align: right;">1</td></tr><tr><td style="text-align: right;">[1]</td><td style="text-align: right;">1</td><td style="text-align: right;">2</td><td style="text-align: right;">3</td><td style="text-align: right;">4</td><td style="text-align: right;">5</td><td style="text-align: right;">6</td><td style="text-align: right;">7</td></tr><tr><td style="text-align: right;">[2]</td><td style="text-align: right;">1</td><td style="text-align: right;">3</td><td style="text-align: right;">6</td><td style="text-align: right;">10</td><td style="text-align: right;">15</td><td style="text-align: right;">21</td><td style="text-align: right;">28</td></tr><tr><td style="text-align: right;">[3]</td><td style="text-align: right;">1</td><td style="text-align: right;">4</td><td style="text-align: right;">10</td><td style="text-align: right;">20</td><td style="text-align: right;">35</td><td style="text-align: right;">56</td><td style="text-align: right;">84</td></tr><tr><td style="text-align: right;">[4]</td><td style="text-align: right;">1</td><td style="text-align: right;">5</td><td style="text-align: right;">15</td><td style="text-align: right;">35</td><td style="text-align: right;">70</td><td style="text-align: right;">135</td><td style="text-align: right;">219</td></tr><tr><td style="text-align: right;">[5]</td><td style="text-align: right;">1</td><td style="text-align: right;">6</td><td style="text-align: right;">21</td><td style="text-align: right;">56</td><td style="text-align: right;">126</td><td style="text-align: right;">261</td><td style="text-align: right;">370</td></tr><tr><td style="text-align: right;">[6]</td><td style="text-align: right;">1</td><td style="text-align: right;">7</td><td style="text-align: right;">28</td><td style="text-align: right;">84</td><td style="text-align: right;">210</td><td style="text-align: right;">471</td><td style="text-align: right;">841</td></tr></tbody></table><p><del>（显而易见）</del>，这里可以利用<ahref="https://baike.baidu.com/item/%E5%8A%A0%E6%B3%95%E5%8E%9F%E7%90%86/7538330?fr=aladdin">加法原理</a>，写出<strong>递推式</strong>：</p><p><span class="math display">\[f[i][j]=f[i-1][j]+f[i][j-1];(start:f[0][0]=1)\]</span></p><h4 id="第二步再加上马的影响">2. 第二步再加上马的影响</h4><table><colgroup><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /></colgroup><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">[0]</th><th style="text-align: center;">[1]</th><th style="text-align: center;">[2]</th><th style="text-align: center;">[3]</th><th style="text-align: center;">[4]</th><th style="text-align: center;">[5]</th><th style="text-align: center;">[6]</th></tr></thead><tbody><tr><td style="text-align: center;">[0]</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">[1]</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;">[2]</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;">[3]</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">[4]</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">0</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">[5]</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">[6]</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">3</td><td style="text-align: center;">3</td><td style="text-align: center;">6</td></tr></tbody></table><p>根据这个表格，我们可以想到先把马的控制点，也就是马能到达的地方（包括他本身的这个点，做一个预处理，之后递推的时候，如果到达马的控制点，直接跳过，继续下一个点。</p><p>基本思路就是这样，但是在测评中发现了第三个点：只有longlong类型才能AC。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span>   </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,m,x,y;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> map[<span class="hljs-number">42</span>][<span class="hljs-number">42</span>]=&#123;&#123;<span class="hljs-number">1</span>&#125;&#125;;  \\递推开始式为f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">bool</span> horse[<span class="hljs-number">42</span>][<span class="hljs-number">42</span>];<br><span class="hljs-keyword">int</span> hx[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-2</span>&#125;,  \\马的位移<br>hy[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">8</span>;i++)<br>&#123;<br><span class="hljs-keyword">int</span> xx=x+hx[i],yy=y+hy[i];<br><span class="hljs-keyword">if</span> (xx&gt;n||xx&lt;<span class="hljs-number">0</span>||yy&gt;m||yy&lt;<span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br>horse[xx][yy]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!horse[<span class="hljs-number">0</span>][++k]&amp;&amp;k&lt;=m)<br>map[<span class="hljs-number">0</span>][k]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (!horse[++l][<span class="hljs-number">0</span>]&amp;&amp;l&lt;=n)<br>map[l][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br><span class="hljs-keyword">if</span> (!horse[i][j])<br>map[i][j]=map[i<span class="hljs-number">-1</span>][j]+map[i][j<span class="hljs-number">-1</span>];   \\递推式<br>cout&lt;&lt;map[n][m]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递推</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
